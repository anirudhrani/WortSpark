{"task_id": 1, "script_title": "array", "task_description": "Accessing and manipulating nested elements within an array.", "code": "a = [1, 2, 3, 4, [5, 6]]\nb = a[2]\nc = a[4]\nd = c[1]\ne = c[1]\nempty = []"}
{"task_id": 2, "script_title": "assignment", "task_description": "Assigning different data types to variables.", "code": "int = 1\nfloat = 2.0\nstr = \"A string\"\nbool_true = True\nbool_false = False\npose = (100, 0, 0, 0, 3.14, 0)\nvec = (200, 100, 0)\narr = [1, 2, 3, 4]"}
{"task_id": 3, "script_title": "async_write", "task_description": "Performing asynchronous write operations to a controller.", "code": "write(controller, 'tool_out[0]', True)\nmove via p2p() to (-200, -600, 300, 0, -3, 0)\nwrite(controller, 'tool_out[0]', False)\nmove via line() to (-200, -600, 100)\na = read(controller, 'tool_out[0]')\nwrite(controller, 'tool_out[0]', True)\nmove via line() to (-200, -600, 150)\nb = read(controller, 'tool_out[0]')"}
{"task_id": 4, "script_title": "blending", "task_description": "Using blending functions to smooth robot motion transitions.", "code": "home = (-200, -600, 250, 0, -pi, 0)\n\nblending(0)\nblending_start = __ms_blending # =0\nvelocity(1000)\n\nmove via p2p() to home\nmove via line() to (0, 200, 0, 0, 0, 0) :: home with blending(1)\nblending_after_single_line = __ms_blending # =0\nwith blending(2):\n    blending_in_context = __ms_blending # =2\n    move via line() to (200, 200, 0, 0, 0, 0) :: home with blending(500)\n    blending_in_context_after_single_line = __ms_blending # =2\nblending_after_context = __ms_blending # =0\nmove via p2p() to home\n\ndef move_line_1(pose):\n    move via line() to pose :: home\n    return __ms_blending\n\nblending_initial_in_function = move_line_1((200, 200, 0, 0, 0, 0)) # =0\n\nwith blending(3):\n    blending_in_context_in_function = move_line_1((200, 200, 0, 0, 0, 0)) # =3\n    move via line() to (200, 0, 0, 0, 0, 0) :: home with blending(500)\n    blending_in_context_after_single_line_in_function = __ms_blending # =3\n\nblending_end = __ms_blending # =0"}
{"task_id": 5, "script_title": "bool_negation", "task_description": "Performing boolean negation operations.", "code": "a = True\nb = ~a\nc = ~b"}
{"task_id": 6, "script_title": "builtins", "task_description": "Controlling digital outputs and handling I/O signals.", "code": "write(controller, \"digital_out[2]\", False)\nwait_for_io(controller, \"digital_out[2]\", False)\nwait_for_bool_io(controller, \"digital_out[2]\", False)"}
{"task_id": 7, "script_title": "collision_scene", "task_description": "Adding and manipulating colliders in a collision scene.", "code": "sphere_pose_default = get_collider_pose(\"sphere_default\")\n\nsphere_pose_set = assoc(sphere_pose_default, 2, 900)\nset_collider_pose(\"sphere_default\", sphere_pose_set)\nsphere_pose_moved = get_collider_pose(\"sphere_default\")\n\nbox_pose = (1000, 0, 0, 0, 0, 0)\nadd_static_box(10, 20, 30, box_pose, \"added_box\")\nadded_box_pose = get_collider_pose(\"added_box\")\n\nvertices = [\n    (0, 0, 1),\n    (1, 0, 1),\n    (0, 1, 0),\n    (0, 1, 1)\n]\nadd_static_convex_hull(vertices, (0, 0, 1200, 0, 0, 0), \"added_convex_hull\")\nadded_convex_hull_pose = get_collider_pose(\"added_convex_hull\")\n\nadd_static_collider_from_json('{\"shape\":{\"type\":\"sphere\", \"radius\":10}, \"pose\":{\"position\":[0, 1100, 0], \"orientation\":[0, 0, 0]}}', \"added_sphere\")\nadded_sphere_pose = get_collider_pose(\"added_sphere\")\n\n# hard to assert, but this also works:\n# add_static_box(10, 20, 80, box_pose, \"added_box_to_remove\")\n# remove_collider(\"added_box_to_remove\")"}
{"task_id": 8, "script_title": "comments", "task_description": "Utilizing comments to explain and annotate code.", "code": "a = 0 # This is an end of line comment\nb = 1 # This as well # and it has the comment marker inside\n# This is a full line comment which should not reassign b  b = 2\n\n# This is a comment with an empty line before\nc = 1\n# This is a comment with an empty line after\n\nd = 1\n\n# This is a comment with empty lines before and after\n\n    # We also allow indented comments\n\ndef foo():\n    # And comments inside of functions\n    a = 2\n    def bar():\n        # In nested functions even\n        a = 3\n        pass  # End of line comments still work here too"}
{"task_id": 9, "script_title": "context", "task_description": "Managing robot poses using context managers.", "code": "def modifier(pose):\n    tmp = __default_orientation\n    __default_orientation = pose\n    def on_exit():\n        __default_orientation = tmp\n    return on_exit\n__default_orientation = 'last'\na = __default_orientation\nwith modifier((0, 0, 0, 0, 0, 0)):\n    b = __default_orientation\nc = a"}
{"task_id": 10, "script_title": "controller", "task_description": "Reading from and writing to a controller\u2019s digital outputs.", "code": "write(controller, \"digital_out[2]\", True)\na_1 = read(controller, \"digital_out[2]\")\nwrite(controller, \"digital_out[2]\", False)\na_2 = read(controller, \"digital_out[2]\")\n\nwrite(controller_b, \"10017#0008\", True)\nb_1 = read(controller_b, \"10017#0008\")\nwrite(controller_b, \"10017#0008\", False)\nb_2 = read(controller_b, \"10017#0008\")"}
{"task_id": 11, "script_title": "coordinate_systems", "task_description": "Defining and working with coordinate systems.", "code": "g = 1\n[a | b] = (0, 0, 10, 0, 0, 0)\n[b | c] = (0, 5, 0, 0, 0, 0)\nd = [c | a]"}
{"task_id": 12, "script_title": "default", "task_description": "Performing repetitive robot movements using loops.", "code": "home = (-189, -600, 260, 0, -pi, 0)\n\nfor i = 0..5:\n    move via p2p() to home\n    move via line() to (50, 20, 30, 0, 0, 0.3) :: home\n    move via line() to (150, 20, 30, 0, 0, 0.3) :: home\n    move via line() to (50, 20, 30, 0, 0, 0.3) :: home\n    move via p2p() to home"}
{"task_id": 13, "script_title": "empty", "task_description": "Defining empty variables or arrays.", "code": ""}
{"task_id": 14, "script_title": "expressions", "task_description": "Performing arithmetic and comparison operations.", "code": "a = 1 + 4\nb = 4 * 2 + 3\nc = 3 + 4 * 2\nd = (3 + 4) * 2\ne = a * 4\nf = 4 - 6\ng = 3 - 2\nh = - 8 + 5\ni = - (8 + 5)\nj, k = [1, 4]\nl = 3 < 4\nm = 4 < 3\nn = True == True\no = False == True\np = a == 5\nq = 5 == a\nr = a == 4\ns = a == a\nt = a - 1 == 4\nu = 4 == a - 1\nv = a + 1 == a + 1\nw = a + 1 == a + 2\nx = True != True\ny = False != True\nz = a != e\n\ndef true():\n    return True\n\naa = true() == true()\nab = [1, 2, 3][0] == [1, 2, 3][0]"}
{"task_id": 15, "script_title": "find_edge_from_4_poses", "task_description": "Finding and moving along an edge using four pose points.", "code": "start_left = (775.2, -473.7, 262.2, 2.916, -0.062, 1.195)  # pose whose xy-plane is parallel to the left surface and the origin is close to start position\nend_left = (795.4, 60.7, 272.7, 2.92, -0.062, 1.185)  # pose whose xy-plane is parallel to the left surface and the origin is close to end position\nstart_right = (799.8, -467.0, 265.4, 2.866, -0.213, -1.158)  # pose whose xy-plane is parallel to the right surface and the origin is close to start position\nend_right = (817.1, 54.6, 255.7, 2.866, -0.213, -1.158)  # pose whose xy-plane is parallel to the right surface and the origin is close to end position\nradius = 8  # the desired radius of the final edge\nspacing = 40  #  the distance between to zig-zag corners\n\nedge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)\nstart  = to_position(edge_poses[0])\nend  = to_position(edge_poses[1])\nn = int(distance(start, end) / spacing)\nplane_orientations = [to_orientation(edge_poses[0]), to_orientation(edge_poses[1])]\ncenter_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)\n\noffset = (0, 0, -radius, 0, 0, 0)\noffset_from_axis = center_rotation :: (0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0) :: ~center_rotation\nb = 0\n\nmove via p2p() to (0, 0, 100, 0, 0, 0) :: to_pose(start) :: offset_from_axis :: plane_orientations[0] :: offset :: (0, 0, -100, 0, 0, 0)\nmove via line() to to_pose(start) :: offset_from_axis :: plane_orientations[0] :: offset\nsync\nwrite(controller, \"10020#0009\", True)\nsync\nfor i = 0..<int(n / 2):\n    c = b\n    a = interpolate(to_pose(start), to_pose(end),(2 * i + 1) / n ) :: offset_from_axis :: center_rotation :: offset\n    b = interpolate(to_pose(start), to_pose(end),(2 * i + 2) / n ) :: offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset\n    python_print(to_position(b))\n    move via arc(a) to b\n    # FIX: without the following line the last motion is a circular and the first motion cannot be a circular\n    move via p2p() to b\n    if i == 1:\n        test_pose = planned_pose()\nsync\nwrite(controller, \"10020#0009\", False)\nsync"}
{"task_id": 16, "script_title": "frame", "task_description": "Defining and transforming frames of reference.", "code": "[tcp | flange] = (0, 0, 100, 0, 0, 0)\n[object | tcp] = (100, 30, 0, pi, 0, 0)\n[robot2 | object] = (0, -300, 0, 0, 0, 0)\nflange2robot = [robot2 | flange]"}
{"task_id": 17, "script_title": "frame2", "task_description": "Manipulating multiple frames of reference for positional transformations.", "code": "[world | red_disk] = (100, 200, 0, 0, 0, 2)\ntop_of_red_disk = (0, 0, 100, 0, 0, 0) :: red_disk\n[world | blue_disk] = (200, 200, 0, pi / 2, 0, 0)\ntop_of_blue_disk = (0, 0, 100, 0, 0, 0) :: blue_disk\na = [red_disk | blue_disk]\nb = [world | top_of_red_disk]"}
{"task_id": 18, "script_title": "frame3", "task_description": "Executing robot movements using various reference frames.", "code": "move [tcp1 | robot1] via p2p() to (-200, -600, 250, 0, -pi, 0)\nmove [tcp2 | robot2] via p2p() to (-200, -500, 250, 0, -pi, 0)\n\na = read(robot1, tcp1)\nb = read(robot2, tcp2)"}
{"task_id": 19, "script_title": "function", "task_description": "Defining and using functions with return values.", "code": "def square(a):\n    return a * a\na = square(12)\ndef power2(c, e):\n    if e:\n        result = c * power2(c, e - 1)\n    else:\n        result = 1\n    return result\nb = power2(3, 4)"}
{"task_id": 20, "script_title": "functional_pose", "task_description": "Manipulating poses through functional composition.", "code": "a = (1, 2, 3, 0.4, 0.5, 0.6)\nb = (4, 2, 5, 0.1, 0.3, 0.5)\nc = a :: b\ndef func_a():\n    return a\ndef func_b():\n    return b\nfunc_c1 = func_a :: b\nevaled_c1 = func_c1()\nfunc_c2 = a :: func_b\nevaled_c2 = func_c2()\nfunc_c3 = func_a :: func_b\nevaled_c3 = func_c3()"}
{"task_id": 21, "script_title": "get_pose", "task_description": "Retrieving and printing the planned robot pose.", "code": "move via p2p() to (-200, -600, 300, 0, pi, 0)\nmove via line() to (-250, -600, 300, 0, pi, 0)\na = planned_pose()\npython_print(a)\nb = read(robot, 'pose')\npython_print(b)"}
{"task_id": 22, "script_title": "ifelse", "task_description": "Implementing conditional logic with if-else statements.", "code": "s = \"c\"\nif s == \"a\":\n    a = 2\nelif s == \"b\":\n    a = 3\nelif s == \"c\":\n    a = 4\nelif s == \"c\":\n    a = 5\nelse:\n    a = 6"}
{"task_id": 23, "script_title": "interpolation", "task_description": "Interpolating between two positions or poses.", "code": "a = (0, 0, 10, 0, 0, 0)\nb = (0, 0, 20, 0, 0, 0)\nc = interpolate(a, b, 0.5)\nd = (0, 0, 0, 0, 0, 0)\ne = (0, 0, 20, 1, 2, 0)\nf = interpolate(d, e, 0.5)"}
{"task_id": 24, "script_title": "interrupt", "task_description": "Capturing robot positions during motion using interrupts.", "code": "a = []\ninterrupt inter1(param, pose) when on_robot_moves():\n    a = a + [pose]\nhome = (832, -452, 289, 0, pi, 0)\nactivate inter1\nmove via p2p() to home\nmove via line() to (0, 0, 100, 0, 0, 0) :: home\nmove via line() to (0, 50, 0, 0, 0, 0) :: home\nsync\nl = len(a)\ndeactivate inter1"}
{"task_id": 25, "script_title": "io", "task_description": "Reading from and writing to input/output controllers.", "code": "write(controller, \"digital_out[2]\", False)\na = read(controller, \"digital_out[2]\")\nwrite(controller, \"digital_out[2]\", True)\nb = read(controller, \"digital_out[2]\")"}
{"task_id": 26, "script_title": "loops", "task_description": "Using loops to execute repeated operations.", "code": "a = 0\nfor i in 0..10:\n    a = a + i\nb = 0\nfor i = 0..10: b = b + i\nc = 0\nfor i = 0..<10:\n    c = c + i\n    c = c + 0\nd = 0\ni = 0\nwhile i < 10:\n    d = d + i\n    i = i + 1"}
{"task_id": 27, "script_title": "move", "task_description": "Executing basic robot movements to specified poses.", "code": "home = (-189, -600, 260, 0, -pi, 0)\nmove via p2p() to home\nmove frame(\"flange\") to (50, 20, 30, 0, 0, 0.3) :: home\nmove via line() to (50, 20, 30, 0, 0, 0) :: home\na = planned_pose()\nmove via line() to a :: (0, 0, -100, 0, 0, 0)"}
{"task_id": 28, "script_title": "move_via_expression", "task_description": "Defining robot movement poses using expressions.", "code": "move via p2p() to (-200, -600, 260 + 3, 0, -pi, 0 + 2)\nmove via line() to (-200, -600, 260, 0, -pi, 0)\na = planned_pose()"}
{"task_id": 29, "script_title": "move_with_velocity", "task_description": "Controlling the velocity of robot movements.", "code": "with velocity(100):\n    velocity_uninitialized_global_inside_context = __ms_velocity\n    move via p2p() to (243, -440, 241, 0, 3, 0)\n# TODO: It's a bit more effort to test this because the velocity is set to Infinity\n# velocity_global_default = __ms_velocity\nvelocity(200)\nvelocity_global_set = __ms_velocity\nmove via p2p() to (150, -355, 389, 0, 3, 0)\nmove via p2p() to (150, -355, 392, 0, 3, 0)\nmove via p2p() to (-95, -363, 387) with velocity(300)\nvelocity_global_after_motion_modifier = __ms_velocity\nwith velocity(400):\n    velocity_global_inside_context = __ms_velocity\n    move via p2p() to (243, -440, 241)\nvelocity_global_after_context = __ms_velocity\na = planned_pose()"}
{"task_id": 30, "script_title": "multiple_robots", "task_description": "Coordinating movements between multiple robots.", "code": "# TODO: needs to be fixed with https://wandelbots.atlassian.net/browse/WOS-1136\ntcp1 = frame(\"tool100\")\ntcp2 = frame(\"TOOL 0\")\n\n# case: no context, frame relation\nmove [tcp1 | robot1] via p2p() to (-200, -600, 250, 0, -pi, 0)\nmove [tcp2 | robot2] via p2p() to (-200, -600, 200, 0, -pi, 0)\nmove [tcp1 | robot1] via p2p() to (-200, -600, 250, 0, -pi, 0)\nmove [tcp2 | robot2] via p2p() to (-200, -500, 250, 0, -pi, 0)\nsync\n\n# case: with context, tcp\ndo with robot1:\n    move tcp1 via p2p() to (-200, -600, 250, 0, -pi, 0)\n    move tcp1 via p2p() to (-200, -600, 250, 0, -pi, 0)\nand do with robot2:\n    move tcp2 via p2p() to (-200, -600, 200, 0, -pi, 0)\n    move tcp2 via p2p() to (-200, -500, 250, 0, -pi, 0)\n\n# case: no context, tcp -> only works with single robot\n# raises wandelscript.exception.WrongRobotError\n# move tcp1 via p2p() to (-200, -600, 250, 0, -pi, 0)\n\na = read(robot1, 'tcp1')\nb = read(robot2, 'tcp2')"}
{"task_id": 31, "script_title": "multiple_robots2", "task_description": "Synchronizing actions between two robots.", "code": "# TODO: needs to be fixed with https://wandelbots.atlassian.net/browse/WOS-1136\ntcp1 = frame(\"tool100\")\ntcp2 = frame(\"TOOL 0\")\ndo with robot1:\n    move tcp1 via p2p() to (-200, -600, 250, 0, -pi, 0)\nand do with robot2:\n    move tcp2 via p2p() to (-200, -600, 200, 0, -pi, 0)\na = read(robot1, tcp1)\nb = read(robot2, tcp2)"}
{"task_id": 32, "script_title": "multiple_robots3", "task_description": "Coordinating robot movements with gripper operations.", "code": "def gripper(open):\n  if open:\n    write(controller, \"digital_out[0]\", True)\n    write(controller, \"digital_out[1]\", False)\n    write(controller, \"digital_out[2]\", True)\n  else:\n    write(controller, \"digital_out[0]\", True)\n    write(controller, \"digital_out[1]\", True)\n    write(controller, \"digital_out[2]\", False)\n\ndo with robot1:\n    move via p2p() to (-189, -600, 260, 0, -pi, 0)\n    gripper(True)\nand do with robot2:\n    move via p2p() to (500, 0, 500, -2, 0, -2)\n    move via p2p() to (500, 0, 500, -2, 0, -2) :: (0, 0, 100)\n    move via p2p() to (500, 0, 500, -2, 0, -2)\n    gripper(False)"}
{"task_id": 33, "script_title": "orientation_relative_to_path", "task_description": "Setting a robot\u2019s orientation relative to a path.", "code": "set_default_orientation('relative')\nset_blending(0.1)\nmove via p2p() to [0, 0, 0, - pi *5 / 4, 0, 0]\nmove via line() to ([1, 0, 0])\nmove via arc([2, 1, 0]) to ([1, 2, 0])\nmove via line() to ([0, 2, 0])\nmove via arc([-1, 1, 0]) to  ([0, 0, 0])\na = planned_pose()"}
{"task_id": 34, "script_title": "palletizing-ur10e-liftkit", "task_description": "Performing palletizing operations with a UR10e and lift kit.", "code": "liftkit_position = \"2:EwellixLiftkit0S/Position\"\nliftkit_status = \"2:EwellixLiftkit0S/Status\"\nliftkit_move = \"2:EwellixLiftkit0S/Move(newPosition)\"\nliftkit_connect = \"2:EwellixLiftkit0S/Connect(host)\"\nliftkit_host = \"192.168.1.100\"\n\nbox_length = read(database, \"box_length\")\nbox_width = read(database, \"box_width\")\nbox_height = read(database, \"box_height\")\npallet_length = box_length * 3\npallet_width = box_width * 2\npallet_layers = 1\nbox_offset = read(database, \"box_offset\")\n\nhome = (-536, -399, 621, 2.88, -1.25507, 0)\npick_pose = (-925, 207, -243, 2.88, -1.2, -0.11) # read(database, \"pickup_base\")\npre_drop_pose = (404, -632, 587, 2.88, -1.25507, 0)\ndrop_pose = (320, -1074, -250, 2.88, -1.25507, 0)\n# drop_pose = (966, -420, -256, 2.88, -1.25507, 0) #  read(database, \"dropoff_base\")\n# other drop pose (-30, -701, -246, 2.88, -1.2, -0.11)\n\napproach_vector = (0, 0, -300)\nliftkit_pick_position = 0.0\ncols = floor(pallet_width / box_width)\nrows = floor(pallet_length / box_length)\n\ndef toggle_gripper(vacuum):\n    if vacuum:\n        write(io, \"tool_out[0]\", False)\n        write(io, \"tool_out[1]\", False)\n    else:\n        write(io, \"tool_out[0]\", True)\n        write(io, \"tool_out[1]\", True)\n        #wait 1000\n        #write(io, \"tool_out[0]\", False)\n        #write(io, \"tool_out[1]\", True)\n\ndef gripper_off():\n    write(io, \"tool_out[0]\", False)\n    write(io, \"tool_out[1]\", True)\n\ndef get_axis_position():\n    return read(opcua, liftkit_position)\n\ndef move_axis(position_in_mm):\n    move via p2p() to home\n    sync\n    call(opcua, liftkit_move, position_in_mm + 0.01)\n    wait 1500\n    while read(opcua, liftkit_status) == \"MOVING\":\n        wait 500\n\ndef calculate_drop_poses(initial_drop_pose):\n    poses = []\n    for c = 0..<cols:\n        for r = 0..<rows:\n            offset_x = r * box_offset\n            offset_y = c * box_offset\n            drop_pose = initial_drop_pose :: (0, 0, 0, 0, 0, 0 * pi / 4) :: (-c * box_width - offset_y, -r * box_length - offset_x, 0, 0, 0, 0) :: (0, 0, 0, 0, 0, 0 * pi / 4)\n            poses = poses + [drop_pose]\n    return poses\n\ndef pick_next_box():\n    move via p2p() to pick_pose :: (0, 0, -300)\n    move via line() to pick_pose\n    sync\n    toggle_gripper(True)\n    move via line() to pick_pose :: (0, 0, -300)\n    move via p2p() to home\n\ndef drop_box(drop_pose):\n    move via p2p() to pre_drop_pose\n    sync\n    move via p2p() to drop_pose :: approach_vector\n    move via line() to drop_pose\n    sync\n    wait 200\n    # BUG: does not respect the wait without the movement\n    toggle_gripper(False)\n    move via p2p() to (0, 0, 1, 0, 0, 0) :: drop_pose\n    sync\n    wait 1000\n    sync\n    move via p2p() to (0, 0, 0, 0, 0, 0) :: drop_pose\n    sync\n    gripper_off()\n    move via line() to drop_pose :: approach_vector\n    move via p2p() to pre_drop_pose\n    move via p2p() to home\n\nposes = calculate_drop_poses(drop_pose)\n\ngripper_off()\n# call(opcua, liftkit_connect, liftkit_host)\nvelocity(1200)\nmove via p2p() to home\n# move_axis(liftkit_pick_position)\n\nfor h = 0..<1:\n    # height_offset = box_height * h\n    for i = 0..len(poses) - 1:\n        # move_axis(liftkit_pick_position)\n        pick_next_box()\n        #move_axis(height_offset)\n        drop_box(poses[i])\n    move via p2p() to home\n\nmove via p2p() to home\n# move_axis(liftkit_pick_position)\ngripper_off()"}
{"task_id": 35, "script_title": "pose", "task_description": "Defining and manipulating pose variables.", "code": "a = (4, 5, 6, 1, 2, 3)\nb = a\nc = (7, 8, 9)\nd = a :: c\n\n# read pose components\na_x = a[0]\na_rz = a[5]\n\n# using negative indices\na_rx = a[-3]\n\n# read position/orientation vector components)\nc_y = c[1]\n\n# \"setting\" pose/position/orientation components\na_new_y = assoc(a, 1, 0)\nc_new_z = assoc(c, 2, c[0])\n\n# also using negative indices\nc_new_y = assoc(c, -2, 42)"}
{"task_id": 36, "script_title": "pose_handling", "task_description": "Managing poses and transformations between frames.", "code": "[tcp | flange] = [0, 0, 100, 0, 0, 0]\n[object | tcp] = [100, 30, 0, pi, 0, 0]\n[robot2 | object] = [0, -300, 0, 0, 0, 0]\nflange2robot = [robot2 | flange]"}
{"task_id": 37, "script_title": "poses2", "task_description": "Transforming positions and poses across reference frames.", "code": "# Lets first define a position 'a'. The position is given by three coordiantes x, y, z in a frame of reference.\n# Lets provide the cooridinates in the world frame of reference.\n\nposition_of_a_in_world = (1, 2, 3)\n\n# The robot (base) is mounted at a specific pose in the world frame of reference. Lets call this pose\n\npose_of_robot_in_world = (30, 20, 10, 0, 0, 0)\n\n# Note this is not a position but a pose. It is a position and an orientation. The orientation is given by the\n# rotation vector (0, 0, 0). This means that the robot is oriented in the same direction as the world frame of reference.\n\n# We can compute the position of 'a' in the robot frame of reference by\n\nposition_of_a_in_robot = ~pose_of_robot_in_world :: position_of_a_in_world\n\n# The '~' operator is used to invert the pose. The '::' operator is used to transform the position from one frame of reference to another.\n\n# Lets print the result\nprint(position_of_a_in_world)\n\n# But in many cases we are not just interested to move to a position, but rather to a precise pose\n\npose_of_a_in_world = (1, 2, 3, 0, 0, 0)\n\n# We can follow the same procedure as before to compute the pose of 'a' in the robot frame of reference\npose_of_a_in_robot = ~pose_of_robot_in_world :: pose_of_a_in_world"}
{"task_id": 38, "script_title": "print", "task_description": "Printing variable values to the console.", "code": "pos = 42.0\nprint(pos)"}
{"task_id": 39, "script_title": "scope", "task_description": "Understanding variable scope in nested functions.", "code": "# This is the global scope\ng = \"global\"\n\ndef get_global():\n    return g\n\ndef set_global(value):\n    g = value\n\ndef local_modified_by_local_setter():\n    outer_var = \"outer value\"\n\n    def get_outer():\n        return outer_var\n\n    def set_outer(value):\n        outer_var = value\n\n    set_outer(\"outer modified\")\n    return get_outer\n\ndef local_modified_by_2nd_level_local_setter():\n    outer_var = \"outer value\"\n\n    def get_outer():\n        return outer_var\n\n    def get_setter():\n        def set_outer(value):\n            outer_var = value\n        return set_outer\n\n    set_outer = get_setter()\n    set_outer(\"outer modified\")\n    return get_outer\n\ndef definition_order_inside_closure():\n    def get_outer():\n        return outer_var\n\n    def set_outer(value):\n        outer_var = value\n\n    set_outer(\"outer modified\")\n    outer_var = \"outer value\"\n    return get_outer\n\n\nglobal_before_modification = get_global()\nset_global(\"global modified\")\nglobal_after_modification = get_global()\n\ngetter = local_modified_by_local_setter()\ng_local_modified_by_local_setter = getter()\n\ngetter = local_modified_by_2nd_level_local_setter()\ng_local_modified_by_2nd_level_local_setter = getter()\n\ngetter = definition_order_inside_closure()\ng_definition_order_inside_closure = getter()"}
{"task_id": 40, "script_title": "spline", "task_description": "Creating smooth robot motion paths using splines.", "code": "a = []\na = a + [[0, (1, 2, 3, 2, 2, 1)]]\na = a + [[1, (2, 2, 3, 4, 5, 6)]]\na = a + [[2, (3, 2, 3, 4, 5, 6)]]\na = a + [[3, (4, 2, 3, 4, 5, 6)]]\na = a + [[4, (5, 2, 3, 4, 5, 6)]]\na = a + [[3, (4, 2, 3, 4, 5, 6)]]\na = a + [[3, (4, 6, 3, 4, 5, 6)]]\na = a + [[3, (4, 5, 3, 4, 5, 6)]]\na = a + [[3, (4, 2, 8, 4, 5, 6)]]\na = a + [[3, (4, 2, 3, 9, 5, 6)]]\nmove via p2p() to (1, 2, 3, 2, 2, 1)\nmove via spline(a) to []"}
{"task_id": 41, "script_title": "switch", "task_description": "Implementing conditional branching with switch-case statements.", "code": "s = \"c\"\nb = 0\nswitch s:\ncase \"a\": b = 2\ncase \"b\": b = 3\ncase \"c\": b = 4\ncase \"c\": b = 5\ndefault: b = 6"}
{"task_id": 42, "script_title": "tcp_change", "task_description": "Changing the robot\u2019s tool center point (TCP).", "code": "flange = frame(\"flange\")\ntool = frame(\"tool\")\nother_tool = frame(to_string(3.0))  # see WOS-463, fanuc related bug\nanother_tool = frame(to_string(4))  # see WOS-463, fanuc related bug\nmove via p2p() to (0, 0, 0, 0, 0, 0)\nmove flange to (1, 2, 0)\nsync\na = read(robot, \"flange\")\nmove tool to (10, 2, 0)\nmove to (1, 24, 0)\nmove to (1, 2, 0)\nsync\nb = read(robot, \"flange\")\nc = read(robot, \"tool\")"}
{"task_id": 43, "script_title": "tower_of_hanoi", "task_description": "Solving the Tower of Hanoi using robot movements.", "code": "# Global reference positions\nhome = (-145.5, -578.3, 77, 0.000, 3.142, 0.000)\napproach = (0, 0, -100, 0, 0, 0)\nrod_left = (-247.1, -726.4, -94, 0.000, pi, 0.000)\nrod_right = (-39.9, -726.4, -94, 0.000, pi, 0.000)\nrod_center = interpolate(rod_left, rod_right, 0.5)\nrods = [rod_left, rod_center, rod_center]\ndisk_height = (158.0 - 125) / 4\nstate = [3, 0, 0]\nwrite(hanoi_state, \"0\", 5)\nwrite(hanoi_state, \"1\", 0)\nwrite(hanoi_state, \"2\", 0)\n\nvelocity(300)\n\ndef set_gripper(close):\n    sync\n    write(io, \"tool_out[0]\", close == False)\n    write(io, \"tool_out[1]\", close)\n    wait(500)\n\ndef action(pose, close):\n    move via line() to pose :: approach\n    move via line() to pose\n    set_gripper(close)\n    velocity(100)\n    move via line() to pose :: approach\n    velocity(300)\n\ndef move_disk(source, target):\n    write(hanoi_state, string(source), read(hanoi_state, string(source)) - 1)\n    action(rods[source] :: (0, 0, - disk_height * read(hanoi_state, string(source)), 0, 0, 0), True)\n    action(rods[target] :: (0, 0, - disk_height * read(hanoi_state, string(target)), 0, 0, 0), False)\n    write(hanoi_state, string(target), read(hanoi_state, string(target)) + 1)\n\ndef tower_of_hanoi(n , source, destination, auxiliary):\n    if n == 1:\n        move_disk(source, destination)\n    else:\n        tower_of_hanoi(n - 1, source, auxiliary, destination)\n        move_disk(source, destination)\n        tower_of_hanoi(n - 1, auxiliary, destination, source)\nmove via p2p() to home\ntower_of_hanoi(5, 0, 1, 2)\nstate = [read(hanoi_state, \"0\"), read(hanoi_state, \"1\"), read(hanoi_state, \"2\")]\nmove via line() to home"}
{"task_id": 44, "script_title": "try", "task_description": "Handling exceptions during robot operations.", "code": "do:\n    move via p2p() to (-200, -600, 260, 0, pi, 0)\n    move via p2p() to (-200, -600, 300, 0, pi, 0)\n    raise \"some artificial error\"\n    move via p2p() to (-200, -600, 250, 0, pi, 0)\nsync:\n    print(\"Hello World\")\nexcept:\n    stopped_pose = read(robot, 'pose')\n    move via p2p() to (-200, -600, 350, 0, pi, 0)\n    final_pose = read(robot, 'pose')"}
{"task_id": 45, "script_title": "vision_move", "task_description": "Guiding robot movements using vision-based frames.", "code": "[flange | tool] = (0, 0, 1, 0, 0, 0)\n[robot_ | object] = (1, 0, 0, 0, 0, 0)\nmove [object | tool] via p2p() to (10, 20, 30, 0, 0, 0)\nb = [robot_ | flange]\nmove [robot_ | flange] via p2p() to (0, 0, 10, 0, 0, 0) :: [robot_ | flange]\nc = [robot_ | flange]"}
{"task_id": 46, "script_title": "wait", "task_description": "Implementing wait commands for synchronization.", "code": "wait 10"}
{"task_id": 47, "script_title": "wandelchat2", "task_description": "Manipulating objects on a table using reference frames.", "code": "world2desk = ~(-140.7, -707.4, 888.1, 0, 0, 0)\n\ndisk_diameter = 100\ndisk_height = 8\n\ndef top_of(pose):\n    return (0, 0, disk_height, 0, 0, 0) :: pose\ndef get_position_right_of(pos):\n    return (disk_diameter, 0, 0, 0, 0, 0) :: pos\ndef get_position_left_of(pos):\n    return (-disk_diameter, 0, 0, 0, 0, 0) :: pos\ndef get_position_front_of(pos):\n    return (0, - disk_diameter, 0, 0, 0, 0) :: pos\ndef get_position_behind_of(pos):\n    return (0, disk_diameter, 0, 0, 0, 0) :: pos\n\ntable = frame(\"table\")\nred_disk = frame(\"red_disk\")\nyellow_disk = frame(\"yellow_disk\")\nblue_disk = frame(\"blue_disk\")\nwhite_disk = frame(\"white_disk\")\ngreen_disk = frame(\"green_disk\")\n\ndef read_all():\n    [table | red_disk] = (300, 100, 0, 0, 0, 0)\n    [table | yellow_disk] = (100, 100, 0, 0, 0, 0)\n    [table | white_disk] = (0, 0, 0, 0, 0, 0)\n    [table | blue_disk] = (100, 0, 0, 0, 0, 0)\n    [table | green_disk] = (0, 100, 0, 0, 0, 0)\nread_all()\n\nrobot2workspace = (-140.7, -707.39, -170, 0.000, 3.142, 0.000)\n\ndef set_gripper(close):\n    sync\n    write(controller, \"tool_out[0]\", close == False)\n    write(controller, \"tool_out[1]\", close)\n    wait(200)\ndef action(position, close):\n    move via p2p() to (position) :: robot2workspace :: (0, 0, -100, 0, 0, 0)\n    move via p2p() to (position) :: robot2workspace\n    set_gripper(close)\n    move via p2p() to (position) :: robot2workspace :: (0, 0, -100, 0, 0, 0)\n    sync\n    read_all()\n\na = 0\nb = 0\ndef move_disk(from_, to_):\n    a = [table | from_]\n    b = [table | to_]\n    action([table | from_], True)\n    action([table | to_], False)\n#def between(a, b):\n#    return to_position(interpolate(to_pose(a), to_pose(b), 0.5))\n#def empty_place():\n#    return get_position_left_of(get_position(\"white_disk\"))\n\n\nmove_disk(red_disk, top_of(blue_disk))"}
{"task_id": 48, "script_title": "wandelchat3", "task_description": "Moving disks between positions using frame transformations.", "code": "world2desk = ~(-140.7, -707.4, 888.1, 0, 0, 0)\n\ndisk_diameter = 100\ndisk_height = 8\n\ndef top_of(pose):\n    return (0, 0, disk_height, 0, 0, 0) :: pose\ndef get_position_right_of(pos):\n    return (disk_diameter, 0, 0, 0, 0, 0) :: pos\ndef get_position_left_of(pos):\n    return (-disk_diameter, 0, 0, 0, 0, 0) :: pos\ndef get_position_front_of(pos):\n    return (0, - disk_diameter, 0, 0, 0, 0) :: pos\ndef get_position_behind_of(pos):\n    return (0, disk_diameter, 0, 0, 0, 0) :: pos\n\ntable = frame(\"table\")\nred_disk = frame(\"red_disk\")\nyellow_disk = frame(\"yellow_disk\")\nblue_disk = frame(\"blue_disk\")\nwhite_disk = frame(\"white_disk\")\ngreen_disk = frame(\"green_disk\")\n\ndef red_disk():\n    return (300, 100, 0, 0, 0, 0)\n def yellow_disk():\n    return (100, 100, 0, 0, 0, 0)\ndef white_disk():\n    return (0, 0, 0, 0, 0, 0)\ndef blue_disk():\n    return (100, 0, 0, 0, 0, 0)\ndef green_disk():\n    return (0, 100, 0, 0, 0, 0)\n\nrobot2workspace = (-140.7, -707.39, -170, 0.000, 3.142, 0.000)\n\ndef set_gripper(close):\n    sync\n    write(controller, \"tool_out[0]\", close == False)\n    write(controller, \"tool_out[1]\", close)\n    wait(200)\n\ndef action(position, close):\n    move via p2p() to robot2workspace :: position :: (0, 0, -100, 0, 0, 0)\n    move via p2p() to robot2workspace :: position\n    set_gripper(close)\n    move via p2p() to robot2workspace :: position :: (0, 0, -100, 0, 0, 0)\n    sync\n\na = 0\nb = 0\ndef move_disk(from_, to_):\n    a = from_()\n    b = to_()\n    action(a, True)\n    action(b, False)\n#def between(a, b):\n#    return to_position(interpolate(to_pose(a), to_pose(b), 0.5))\n#def empty_place():\n#    return get_position_left_of(get_position(\"white_disk\"))\n\n\nmove_disk(red_disk, top_of(blue_disk))"}
{"task_id": 49, "script_title": "wandelday", "task_description": "Controlling robot drawing motions with precise coordinates.", "code": "canvas_left_bottom_corner = (32.6, -1032.9, 612.3)\ncanvas_right_bottom_corner = (-10.4, -685.6, 612.3)\ncanvas_middle_top_position = (-29.3, -896.6, 849.8)\npose_canvas_to_robot = estimate_plane(canvas_left_bottom_corner, canvas_right_bottom_corner, canvas_middle_top_position)\n# pose_canvas_to_robot = (32.6, -1032.9, 612.3, 1.018, 1.152, 1.389)\n\npose_pentip_to_point = (0, 0, -12, 0, 0, 0) :: (0, 0, 0, 0, 0.6, 0) :: (0, 0, 0, 2.22, 2.22, 0)\n\nhome = read(robot, \"pentip\")\nmove via p2p() to home\nfont_height = 30\nfont_width = 20\n\nmovedef line_in_air(start >--> end):\n    offset = (0, 0, -10, 0, 0, 0)\n    move via line() to start :: offset\n    move via line() to end :: offset\n    move via line() to end\n\n\nwith velocity(100):\n    move via line() to pose_canvas_to_robot :: (0, 0, 0, 0, 0, 0) ::  pose_pentip_to_point\n    move via line() to pose_canvas_to_robot :: (0, 400, 0, 0, 0, 0) ::  pose_pentip_to_point\n    move via line() to pose_canvas_to_robot :: (400, 400, 0, 0, 0, 0) ::  pose_pentip_to_point\n    move via line() to pose_canvas_to_robot :: (400, 400, 0, 0, 0, 0) :: pose_pentip_to_point\n    move via line() to pose_canvas_to_robot :: (400, 0, 0, 0, 0, 0) ::  pose_pentip_to_point\n\n\n    pose_letter_to_canvas = (100, 100, 0, 0, 0, 0)\n    pose_letter_to_robot = pose_canvas_to_robot :: pose_letter_to_canvas\n\n\n    # letter D\n    move via line() to pose_letter_to_robot :: (0, 0, 0, 0, 0, 0) ::  pose_pentip_to_point\n    move via line() to pose_letter_to_robot :: (0, font_height, 0, 0, 0, 0) ::  pose_pentip_to_point\n    middle = to_position(pose_letter_to_robot :: (font_width, font_height/2, 0, 0, 0, 0) ::  pose_pentip_to_point)\n    move via arc(middle) to pose_letter_to_robot :: (0, 0, 0, 0, 0, 0) ::  pose_pentip_to_point\n    move via line() to pose_letter_to_robot :: (0, 0, 0, 0, 0, 0) ::  pose_pentip_to_point\n\n\n\n    pose_letter_to_canvas = (1.5 * font_width, 0, 0, 0, 0, 0) :: pose_letter_to_canvas\n    pose_letter_to_robot = pose_canvas_to_robot :: pose_letter_to_canvas\n\n    sync\n    a = read(robot, \"flange_renamed\")\n\n    # letter V\n    move via line_in_air() to pose_letter_to_robot :: (0, font_height, 0, 0, 0, 0) :: pose_pentip_to_point\n    move via line() to pose_letter_to_robot :: (font_width/2, 0, 0, 0, 0, 0) ::  pose_pentip_to_point\n    move via line() to pose_letter_to_robot :: (font_width, font_height, 0, 0, 0, 0) ::  pose_pentip_to_point\n\n    move via p2p() to home"}
{"task_id": 50, "script_title": "whitespaces", "task_description": "Maintaining code readability through proper whitespace usage.", "code": "a = 1\nb = 2   \n\nc = 3"}
{"task_id": 51, "script_title": "wp393", "task_description": "Moving a robot between predefined home positions.", "code": "home = (100, -300, 500, 0, pi, 0)\n\nvelocity(50)\nmove via p2p() to home\nmove via line() to home :: (0, 0, 100)\nsync\nmove via line() to home :: (100, 0, 0)\n# move via line() to home :: (100, 0, 0)"}
{"task_id": 52, "script_title": "wp469", "task_description": "Executing robot movements with varying velocities.", "code": "home = (400, -100, 300, 0, pi, 0)\n\nvelocity(2000)\nmove via p2p() to home\nmove via p2p() to home :: (0, 0, 100, 0, 0, 0)\nmove via p2p() to home :: (0, 0, -100, 0, 0, 0)\nwith velocity(100):\n    move via arc(home :: (0, 100, 200, 0, 0, 0)) to home :: (0, 0, 400, 0, 0, 0) with velocity(100)"}
{"task_id": 1, "script_title": "cell_1_robot_agnostic_loop", "task_description": "Accessing and manipulating nested elements within an array.", "code": "# Robot Agnostic \n\nC1_HOME_J = [1.3950, 0.6053, 0.3194, 0.0089, 0.6564, 1.3092]\n\nC1_PICK_APPROACH_ROTATED = (-62.1, 421.9, 434.9, -2.223, -2.22, 0)\nC1_PICK_1 = (-44.9, 412.9, 118.8, 0, -3.1, 0)\nC1_PICK_2 = (-231, 383.2, 119.1, 0, -3.1001, 0.0002)\nC1_PICK_3 = (-265.7, 567.5, 118.8, -0.0001, -3.1079, 0.0113)\nC1_PICK_4 = (-81.1, 595.1, 118.8, -0.0003, -3.1019, 0.0062)\n\n\n# Piece 1\nC1_SCANNER_APPROACH = (237.3, 478.1, 457.8, -2.225, -2.222, 0)\nC1_SCANNER = (352.9, 478.1, 457.8, -2.224, -2.221, 0)\nC1_SCANNER_LEAVE = (353.6, 319.0, 457.7, -2.226, -2.223, 0)\n\n# Piece 2\nC1_SCANNER_APPROACH_2 = (237.3, 478.1, 457.8, 0, -3.1, 0)\nC1_SCANNER_2 = (352.9, 478.1, 457.8, 0, -3.1, 0)\nC1_SCANNER_LEAVE_2 = (353.6, 319.0, 457.7, 0, -3.1, 0)\n\nC1_PLACE_APPROACH = (484.3, 15.3, 200.9, -3.148, 0, 0)\nC1_PLACE_1 = (452.2, -12.1, 132, 3.1, 0.0, 0.0)\nC1_PLACE_2 = (635, 5, 132, 3.1367, 0, -0.0054)\n\ndef cell1_abb_open_gripper():\n    write(cell1_abb, True, \"Local/SC_1/SC1CBCOK\")\n    write(cell1_abb, False, \"Local/SC_1/SC1CBCPREWARN\")\n\n\ndef cell2_abb_close_gripper():\n    write(cell1_abb, False, \"Local/SC_1/SC1CBCOK\")\n    write(cell1_abb, True, \"Local/SC_1/SC1CBCPREWARN\")\n\n# ---------------- programm ------------ '\nvelocity(300)\n\ncell1_abb_open_gripper()\n\ndo with cell1_abb_0:\n    move via joint_p2p() to C1_HOME_J\n    move via p2p() to C1_PICK_2 :: (0, 0, -50, 0, 0, 0)\n    move via line() to C1_PICK_2\n    cell2_abb_close_gripper()\n\nwait(1000)\n\ndo with cell1_abb_0:\n    move via line() to C1_PICK_2 :: (0, 0, -50, 0, 0, 0)\n    move via line() to C1_SCANNER_APPROACH_2\n    move via line() to C1_SCANNER_2 with velocity(50)\n\nwait(2000)\n\ndo with cell1_abb_0:\n    move via line() to C1_SCANNER_APPROACH_2 with velocity(50)\n    move via line() to C1_PLACE_2 :: (0, 0, -50, 0, 0, 0)\n    move via line() to C1_PLACE_2 with velocity(50)\n    cell1_abb_open_gripper()\n\nwait(1000)\n\nvelocity(300)\ndo with cell1_abb_0:\n    move via line() to C1_PLACE_APPROACH\n    move via joint_p2p() to C1_HOME_J\n\n# Bringe back\nwait(2000)\ndo with cell1_abb_0:\n    move via p2p() to C1_PLACE_2 :: (0, 0, -50, 0, 0, 0)\n    move via p2p() to C1_PLACE_2 :: (0, 0, 12.8, 0, 0, 0) with velocity(50)\n    cell2_abb_close_gripper()\n\nwait(500)\n\ndo with cell1_abb_0:\n    move via p2p() to C1_PLACE_2 :: (0, 0, -50, 0, 0, 0)\n    move via joint_p2p() to C1_HOME_J\n    move via p2p() to C1_PICK_2 :: (0, 0, -50, 0, 0, 0)\n    move via p2p() to C1_PICK_2 :: (0, 0, -5, 0, 0, 0)\n    cell1_abb_open_gripper()\n\nwait(500)\n\ndo with cell1_abb_0:\n    move via joint_p2p() to C1_HOME_J"}
{"task_id": 2, "script_title": "cell_2_mounting_options", "task_description": "Assigning different data types to variables.", "code": "# Mounting Options\n\nC2_HOME_J = [1.5897, 3.27264, -0.76968, -3.7037, -0.0100, 0.5302]\nC2_PICK_1_APPROACH_J = [1.4261, 3.7930, -1.9048, -2.0187, -0.1638, -0.8059]\nC2_PICK_1_J = [1.2423, 3.7864, -1.8289, -2.0036, -0.3255, -0.6244]\nC2_PICK_2_J = [1.2158, 3.3697, -1.6964, -1.7163, -0.3776, -0.6278]\nC2_PICK_3_J = [1.3194, 3.1702, -1.0822, -2.1466, -0.2741, -0.6114]\nC2_PICK_4_J = [1.3332, 3.5116, -1.2306, -2.3426, -0.2604, -0.6082]\n\nC2_PICK_2 = (381.6, 413.8, -46.6, 0.7134, 1.4655, 0.6981)\n\n# Platine 1\nC2_SCANNER_APPROACH = (30.0, 488.8, 200.1, 1.9, 0.6, 1.9)\nC2_SCANNER = (36.6, 467.8, 314.5, 1.9, 0.6, 1.9)\nC2_SCANNER_LEAVE = (36.6, 330, 314.5, 1.9, 0.6, 1.9)\n\n# Platine 2\nC2_SCANNER_APPROACH_2 = (30.0, 488.8, 200.1,  0.7077, 1.4675, 0.7426)\nC2_SCANNER_2 = (36.6, 467.8, 314.5,  0.7077, 1.4675, 0.7426)\nC2_SCANNER_LEAVE_2 = (36.6, 330, 314.5,  0.7077, 1.4675, 0.7426)\n\nC2_PLACE_1_APPROACH = (272.4, 31.2, 472.2, -1.7, 0.9, -1.7)\nC2_PLACE_2_APPROACH = (341.1, 22.2, 620.6, -0.4896, 1.4767, -0.506)\n\nC2_PLACE_1 = (352.3, -8.5, 446.2, -1.7, 0.9, -1.7)\nC2_PLACE_2 = (381.1, 10.7, 623.8, -0.4896, 1.4767, -0.506)\n\ndef cell2_ur_open_gripper():\n    write(cell2_ur, True, \"tool_out(0)\")\n    write(cell2_ur, False, \"tool_out(1)\")\n\ndef cell2_ur_close_gripper():\n    write(cell2_ur, False, \"tool_out(0)\")\n    write(cell2_ur, True, \"tool_out(1)\")\n\n\n# ---------------- programm ------------ '\nvelocity(300)\n\ncell2_ur_open_gripper()\ndo with cell2_ur_0:\n    move via joint_p2p() to C2_HOME_J\n    move via p2p() to C2_PICK_2 :: (0, 0, -50, 0, 0, 0)\n    move via p2p() to C2_PICK_2\n    cell2_ur_close_gripper()\n\nwait(1000)\n\ndo with cell2_ur_0:\n    move via p2p() to C2_PICK_2 :: (0, 0, -50, 0, 0, 0)\n    move via p2p() to C2_SCANNER_APPROACH\n    move via line() to C2_SCANNER with velocity(50)\n\nwait(2000)\n\ndo with cell2_ur_0:\n    move via line() to C2_SCANNER_LEAVE_2 with velocity(50)\n    move via p2p() to C2_PLACE_2 :: (0, 0, -50, 0, 0, 0)\n    move via p2p() to C2_PLACE_2 :: (0, 0, -12, 0, 0, 0) with velocity(50)\n    cell2_ur_open_gripper()\n\nwait(1000)\n\nvelocity(300)\ndo with cell2_ur_0:\n    move via p2p() to C2_PLACE_2 :: (0, 0, -50, 0, 0, 0)\n    move via p2p() to C2_SCANNER_LEAVE_2\n    move via joint_p2p() to C2_HOME_J\n\n\nwait(2000)\n\ndo with cell2_ur_0:\n    move via joint_p2p() to C2_HOME_J\n    move via p2p() to C2_SCANNER_APPROACH_2\n    move via p2p() to C2_SCANNER_LEAVE_2\n    move via p2p() to C2_PLACE_2 :: (0, 0, -50, 0, 0, 0)\n    move via p2p() to C2_PLACE_2 with velocity(50)\n    cell2_ur_close_gripper()\n\nwait(500)\n\ndo with cell2_ur_0:\n    move via line() to C2_PLACE_2 :: (0, 0, -100, 0, 0, 0)\n    move via p2p() to C2_SCANNER_LEAVE_2\n    move via p2p() to C2_SCANNER_APPROACH_2\n    move via p2p() to C2_PICK_2 :: (0, 0, -50, 0, 0, 0)\n    move via p2p() to C2_PICK_2 :: (0, 0, -10, 0, 0, 0) with velocity(50)\n    cell2_ur_open_gripper()\n\nwait(500)\n\ndo with cell2_ur_0:\n    move via p2p() to C2_PICK_2 :: (0, 0, -100, 0, 0, 0)\n    move via joint_p2p() to C2_HOME_J"}
{"task_id": 3, "script_title": "combined", "task_description": "Performing asynchronous write operations to a controller.", "code": "# ================================================================================\n#  Variables - Kuka Main\n# ================================================================================\nkm_toolrot = (0,0,0,pi,0,0) ::(0,0,0,0,pi/2,0)\nkm_pickup_pose_adjust = (0,0,0,0,0,0)\n\nkm_home = (-1196.459, 1120.134, 39.639, 0.000, 0.000, -1.571) :: km_toolrot\nkm_home_approach = (-300.631, 1553.848, 713.290, 0.314, 0.149, -2.240) :: km_toolrot\nkm_end = (1124.216, -270.612, 1287.374, 0.000, 0.000, 0.000) :: km_toolrot\n\nkm_pickup = (-1690.493, 595.949, 1402.813, -1.657, 0.000, 2.669) :: km_toolrot :: km_pickup_pose_adjust\nkm_pickup_approach_01 = (-1170, 596.021, 1660.652, -1.618, 0.051, 2.581) :: km_toolrot\nkm_pickup_approach_02 = km_pickup :: (-200,0,0,0,0,0)\n\nkm_assembly_01 = (35.734, 1312.842, 1848.345, 0.464, -0.541, 2.484) :: km_toolrot\nkm_assembly_02 = (1467.229, -724.335, 1451.327, 0.098, -0.113, 1.424) :: km_toolrot\nkm_assembly_03 = (1934.054, -255.538, 1220.853, 0.000, 0.000, 1.571) :: km_toolrot\nkm_assembly_04 = (1934.054, 135.126, 1853.223, -0.373, 0.373, 1.538) :: km_toolrot\nkm_assembly_05 = (1934.054, 1264.324, 1228.771, -0.373, 0.373, 1.538) :: km_toolrot\nkm_assembly_06 = (1934.054, 1666.440, 1053.255, -0.128, 0.128, 1.567) :: km_toolrot\n\nkm_assembly_07 = (1934.054, 1648.191, 1074, 0.000, 0.000, 1.571) :: km_toolrot :: (-10,0,0,0,0,0)\nkm_assembly_dachhimmel = km_assembly_07 :: (10,0,0,0,0,0)\n\n# ================================================================================\n#  Variables - Kuka Side2\n# ================================================================================\nks1_TCProt = (0,0,0,0,0,pi)\nks1_modifier_01 = (0,0,-3,0,0,-0.03)\nks1_modifier_02 = (0,0,-0.5,0,0,0.02)\n\nks1_home = (-162.759, 761.844, 1022.213, -2.221, 0.000, 2.221) :: ks1_TCProt\nks1_wait_pose_01 = (1275.687, -641.851, 1150.906, -2.221, -0.000, -2.221) :: ks1_TCProt\nks1_entry_pose_01 = (2020.808, -663.201, 1248.459, 0.836, 0.000, 3.028) :: ks1_TCProt\nks1_assembly_pose_01 = (2464.615, -743.862, 1300, 0.004, -0.091, 3.137) :: ks1_TCProt :: ks1_modifier_01\n\nks1_wait_pose_02 = (1324.971, 302.697, 1113.379, -2.221, -0.000, -2.221) :: ks1_TCProt\nks1_entry_pose_02 = (1995.329, 213.900, 1224.313, -0.793, 0.264, -2.972) :: ks1_TCProt\nks1_assembly_pose_02 = (2468.995, -21.849, 1295, 0.021, -0.210, -3.128) :: ks1_TCProt :: ks1_modifier_02\n\nks1_approach_assembly_01 = ks1_assembly_pose_01 :: (0,0,-150,0,0,0)\nks1_approach_assembly_02 = ks1_assembly_pose_02 :: (0,0,-150,0,0,0)\n\n# ================================================================================\n#  Variables - Kuka Side2\n# ================================================================================\n\nks2_TCProt = (0,0,0,0,0,pi)\nks2_modifier_01 = (0,0,-3,0,0,1)\nks2_modifier_02 = (0,0,-3,0,0,-1)\n\nks2_home = (-162.759, 761.844, 1022.213, -2.221, 0.000, 2.221) :: ks2_TCProt\nks2_wait_pose_01 = (1082.062, 641.850, 1150.906, -2.221, -0.000, -2.221) :: ks2_TCProt\nks2_entry_pose_01 = (1827.183, 663.200, 1148.459, -0.836, 0.000, -3.028) :: ks2_TCProt\nks2_assembly_pose_01 = (2257.000, 712, 1301.5, -0.0, -0.085, -3.3) :: ks2_TCProt :: ks2_modifier_01\n\nks2_wait_pose_02 = (1131.346, -302.700, 1113.379, -2.221, -0.000, -2.221) :: ks2_TCProt\nks2_entry_pose_02 = (1801.704, -213.900, 1124.313, 0.800, 0.258, 2.990) :: ks2_TCProt\nks2_assembly_pose_02 = (2240.000, -16.190, 1297, 0.023, -0.168, 3.076) :: ks2_TCProt :: ks2_modifier_02\n\nks2_approach_assembly_01 = ks2_assembly_pose_01 :: (0,0,-100,0,0,0)\nks2_approach_assembly_02 = ks2_assembly_pose_02 :: (0,0,-100,0,0,0)\n\n# ================================================================================\n# Functions\n# ================================================================================\ndef wake_up():\n    km_pose = read(kuka_main_0, 'pose')\n    ks1_pose = read(kuka_side1_0, 'pose')\n    ks2_pose = read(kuka_side2_0, 'pose')\n    do with kuka_main_0:\n        move via p2p() to km_pose\n    and do with kuka_side1_0:\n        move via p2p() to ks1_pose\n    and do with kuka_side2_0:\n        move via p2p() to ks2_pose\n    sync\n\n# ================================================================================\n# Main Program\n# ================================================================================\nwake_up()\n\ndo with kuka_main_0:\n    move via p2p() to km_home\n\nwait(100)\n\ndo with kuka_side1_0:\n    move via p2p() to ks1_home\nand do with kuka_side2_0:\n    move via p2p() to ks2_home\n\nwait(1000)\nwrite(kuka_main, False, \"$OUT(1)\") # support leg\nwrite(kuka_main, False, \"$OUT(7)\") # Suction Assembly\nwrite(kuka_main, False, \"$OUT(8)\") # robot trigger\n\n#----------home to pickup-------#\ndo with kuka_main_0:\n    move via p2p() to km_home\n    move via line() to km_home_approach\n    move via p2p() to km_pickup_approach_01\n    move via p2p() to km_pickup_approach_02\n    move via line() to km_pickup with velocity(80)\n\nwait(500)\nwrite(kuka_main, True, \"$OUT(6)\") # Suction Gripper\nwait(1500)\n\n\n#----------pickup to assembly-------#\ndo with kuka_main_0:\n    move via p2p() to km_pickup\n    move via line() to km_pickup_approach_01\nand do with kuka_side1_0:\n    move via p2p() to ks1_home\n    move via p2p() to ks1_wait_pose_01\nand do with kuka_side2_0:\n    move via p2p() to ks2_home\n    move via p2p() to ks2_wait_pose_01\n\nwait(500)\ndo with kuka_main_0:\n    move via p2p() to km_assembly_01\n    move via p2p() to km_assembly_02\n    move via line() to km_assembly_03\n    move via line() to km_assembly_04 with velocity(300)\n    move via line() to km_assembly_05 with velocity(300)\n    move via line() to km_assembly_06 with velocity(300)\n    move via line() to km_assembly_07 with velocity(300)\nwait(500)\nwrite(kuka_main, True, \"$OUT(7)\") # Essembly\nwrite(kuka_main, True, \"$OUT(1)\") # open leg\n\n\n# ---------- Side Robots ---------- #\ndo with kuka_side1_0:\n    move via p2p() to ks1_entry_pose_01\n    move via line() to ks1_approach_assembly_01\nand do with kuka_side2_0:\n    move via p2p() to ks2_entry_pose_01\n    move via line() to ks2_approach_assembly_01\n\n# ---------- Put Ceiling into Chassis ---------- #\n\nwait(300)\ndo with kuka_main_0:\n    move via p2p() to km_assembly_07\n    move via line() to km_assembly_dachhimmel with velocity(50)\n\nwait(300)\n\n# ---------- Side Robots ---------- #\n# ---------- Back ---------- #\ndo with kuka_side1_0:\n    move via p2p() to ks1_approach_assembly_01\n    move via line() to ks1_assembly_pose_01 with velocity(50)\nand do with kuka_side2_0:\n    move via p2p() to ks2_approach_assembly_01\n    move via line() to ks2_assembly_pose_01 with velocity(50)\n\nwait(200)\n\ndo with kuka_side1_0:\n    move via p2p() to ks1_approach_assembly_01 with velocity(300)\n    move via line() to ks1_entry_pose_01\n    move via line() to ks1_wait_pose_01 with blending(150)\nand do with kuka_side2_0:\n    move via p2p() to ks2_approach_assembly_01 with velocity(300)\n    move via line() to ks2_entry_pose_01\n    move via line() to ks2_wait_pose_01\n\n# ---------- Front ---------- #\n\ndo with kuka_side1_0:\n    move via line() to ks2_wait_pose_02\nand do with kuka_side2_0:\n    move via line() to ks2_wait_pose_02\n\ndo with kuka_side1_0:\n    move via line() to ks2_entry_pose_02\n    move via p2p() to ks1_approach_assembly_02\n    move via line() to ks1_assembly_pose_02 with velocity(50)\nand do with kuka_side2_0:\n    move via line() to ks2_entry_pose_02\n    move via p2p() to ks2_approach_assembly_02\n    move via line() to ks2_assembly_pose_02 with velocity(50)\n\nwait(200)\n\ndo with kuka_side1_0:\n    move via p2p() to ks1_approach_assembly_02 with velocity(300)\n    move via line() to ks1_entry_pose_02\n    move via line() to ks1_wait_pose_02 with blending(150)\nand do with kuka_side2_0:\n    move via p2p() to ks2_approach_assembly_02 with velocity(300)\n    move via line() to ks2_entry_pose_02\n    move via line() to ks2_wait_pose_02\n\n# ---------- Back to Home ---------- #\n\nwait(200)\nwrite(kuka_main, False, \"$OUT(6)\") # Suction Gripper\nwait(200)\n\ndo with kuka_main_0:\n    move via line() to km_assembly_06 with velocity(50)\n    move via line() to km_assembly_05 with velocity(300)\n    move via line() to km_assembly_04 with velocity(300)\n    move via line() to km_assembly_03\n    move via p2p() to km_assembly_02\n    move via p2p() to km_end"}
{"task_id": 4, "script_title": "demo_cell_physic", "task_description": "Using blending functions to smooth robot motion transitions.", "code": "# robot poses\nUR_HOME = (508.1, 140.1, 569.2, pi, 0, 0)\n\nUR_PICK_01 = (-13.8, -374.2, 337.0, pi, 0, 0)\nUR_PICK_APPROACH_OFFSET = -100\n\nUR_PLACE = (404.0, 535.4, 448.5, pi, 0, 0)\nUR_PLACE_APPROACH_OFFSET = -80\n\nABB_HOME = (524.6, -250.3, 578.4, 0, 0, 2.9)\nABB_PICK_APPROACH = (398, -450.6, 460, 0, -0.3, 2.9)\nABB_PICK = (398, -450.6, 420, 0, -0.3, 2.9)\nABB_DROP = (25.5, 673.5, 424.8, 0, 0, 2.9)\n\n# Conveyor:\n# Run the conveyor to the right (velocity > 0)\nCONVEYOR_TRIGGER = \"digital_out(4)\"\nCONVEYOR_LEFT = \"digital_out(5)\"\nCONVEYOR_RIGHT = \"digital_out(6)\"\n\nSENSOR_CONVEYOR_RIGHT = \"digital_in(0)\"\nSENSOR_CONVEYOR_LEFT = \"digital_in(1)\"\n\nDI_04_BUTTON_IO = \"digital_in(4)\"\nDI_05_BUTTON_IO = \"digital_in(5)\"\n\nLIGHT_TABLE = \"digital_out(7)\"\n\nUR_TCP = frame(\"TCP\")\n\n# Set this to true when you run the skill only on virtual robot\nIS_ONLY_VIRTUAL = False \n\ndef start_conveyor_right():\n    write(ur, True, \"digital_out(4)\")\n    write(ur, False, \"digital_out(5)\")\n    write(ur, True, \"digital_out(6)\")\n\ndef stop_conveyor():\n    write(ur, True, \"digital_out(4)\")\n    write(ur, False, \"digital_out(5)\")\n    write(ur, False, \"digital_out(6)\")\n\ndef start_conveyor_left():\n    write(ur, True, \"digital_out(4)\")\n    write(ur, True, \"digital_out(5)\")\n    write(ur, False, \"digital_out(6)\")\n\n# UR suction gripper\ndef open_ur_gripper():\n    write(ur, True, \"tool_out(0)\")\n    write(ur, False, \"tool_out(1)\")\n    \ndef close_ur_gripper():\n    write(ur, False, \"tool_out(0)\")\n    write(ur, True, \"tool_out(1)\")\n\n# ABB parallel gripper\ndef open_abb_gripper():\n    write(ur, True, \"digital_out(0)\")\n    write(ur, False, \"digital_out(1)\")\n    write(ur, True, \"digital_out(2)\")\n\ndef close_abb_gripper():\n    write(ur, True, \"digital_out(0)\")\n    write(ur, True, \"digital_out(1)\")\n    write(ur, False, \"digital_out(2)\")\n\nSL_RED = 22\nSL_YELLOW = 21\nSL_GREEN = 20\n\ndef stack_light(light, on):    \n    if IS_ONLY_VIRTUAL == True:\n        print(\"OPCUA is not yet supported.\")\n    else:\n        write(opcua, on, \"4:Numeric:\" + to_string(light))\n\ndef light_table(on):\n    write(ur, on, LIGHT_TABLE)\n\ndef startup():\n    open_ur_gripper()\n    open_abb_gripper()\n    stop_conveyor()\n    start_conveyor_left()\n\ndef get_grid_pose(corner_pose, idx):\n    grid_step = 87\n    grid_n = 3\n    dir_1 = (grid_step * modulo(idx, grid_n), 0, 0, 0, 0, 0)\n    dir_2 = (0, grid_step * intdiv(idx, grid_n), 0, 0, 0, 0)\n    pose_for_idx = corner_pose :: dir_1 :: dir_2\n    return pose_for_idx\n\ndef single_box(box_num):\n    velocity(200)\n    acceleration(200)\n    ur_pick = get_grid_pose(UR_PICK_01, box_num)\n    ur_pick_approach = ur_pick :: (0, 0, UR_PICK_APPROACH_OFFSET, 0, 0, 0)\n\n    do with ur_0:\n        move UR_TCP via p2p() to UR_HOME\n        move UR_TCP via p2p() to ur_pick_approach with velocity(800)\n        move UR_TCP via line() to ur_pick with velocity(50)\n        close_ur_gripper()\n    wait(1000)\n\n    ur_place_approach = UR_PLACE :: (0, 0, UR_PLACE_APPROACH_OFFSET, 0, 0, 0)\n    do with ur_0:\n        move UR_TCP via line() to ur_pick_approach\n        start_conveyor_left()\n        with blending(50), velocity(800):\n            move UR_TCP via p2p() to UR_HOME\n            move UR_TCP via line() to ur_place_approach\n        move UR_TCP via line() to UR_PLACE with velocity(100)\n        open_ur_gripper()\n    wait(1000)\n\n    do with ur_0:\n        start_conveyor_right()\n        move UR_TCP via line() to ur_place_approach\n        move UR_TCP via p2p() to UR_HOME\n    and do with abb_0:\n        move via p2p() to ABB_HOME\n        move via line() to ABB_PICK_APPROACH\n    \n    if IS_ONLY_VIRTUAL == False:\n        wait_for_bool_io(ur, SENSOR_CONVEYOR_RIGHT, True)\n    else:\n        wait(1000)\n\n    do with abb_0:\n        move via line() to ABB_PICK with velocity(50)\n        stop_conveyor()\n\n        close_abb_gripper()\n    wait(500)\n\n    do with abb_0:\n        move via line() to ABB_PICK_APPROACH with velocity(50)\n        with blending(50), velocity(200):\n            move via p2p() to ABB_HOME \n            move via p2p() to ABB_DROP\n\n        open_abb_gripper()\n        move via line() to ABB_DROP :: (0, 0, 10) with velocity(200)\n\n    wait(1000)\n\n    do with abb_0:\n        move via line() to ABB_HOME with velocity(200)\n\n    stop_conveyor()\n\ndef main(start_box, end_box):\n    stack_light(SL_YELLOW, False)\n    stack_light(SL_GREEN, True)\n\n    for box_num = (start_box-1)..(end_box-1):\n        print(box_num)\n        button_di_04_pressed = False\n        button_di_05_pressed = False\n\n        while True:\n            button_di_05_not_pressed = read(ur, DI_05_BUTTON_IO)\n            if read(ur, DI_04_BUTTON_IO) == True:\n                button_di_04_pressed = True\n                break\n            if read(ur, DI_05_BUTTON_IO) == True:\n                button_di_05_pressed = True\n                break\n\n        # reset_cell()\n        if button_di_04_pressed:\n            stack_light(SL_RED, True)\n            stack_light(SL_GREEN, False)\n            print(\"NEXT\")\n            light_table(True)\n            single_box(box_num)\n            button_di_04_pressed = False\n            light_table(False)\n            stack_light(SL_RED, False)\n            stack_light(SL_GREEN, True)\n        if button_di_05_pressed:\n            print(\"RESET\")\n            box_num = 0\n            light_table(True)\n            single_box(box_num)\n            button_di_05_pressed = False\n            light_table(False)\n\n    stack_light(SL_RED, False)\n    stack_light(SL_GREEN, False)\n    stack_light(SL_YELLOW, True)\n\nstartup()\nmain(1, 1)"}
{"task_id": 5, "script_title": "multirobot_2robots_picknplace", "task_description": "Performing boolean negation operations.", "code": "# defines the pick position of the box\n# 0 - 8 --> back to 0\nTCP_Sucker = frame(\"WOS_Sucker\")\nTCP_HookedHook = frame(\"WOS_HookedHook\")\nTCP_ABB = frame(\"BASE/tool0\")\nLEFT_SENSOR_IO = \"digital_in[1]\"\nRIGHT_SENSOR_IO = \"digital_in[0]\"\nRED_BUTTON_IO = \"digital_in[2]\"\nGREEN_BUTTON_IO = \"digital_in[3]\"\nprod = False\ndebug = False\nrun_no = 0\nabb_home = (475.7, -94.4, 553.8, -0.027, -0.024, 1.176)\nur_home = (191.6, -717.3, 433.2, 0, pi, 0)\nur_pick_pose = (184, -1038, 150, 0, pi, 0)\nur_drop_pose = (460, -832, 346, 0, pi, 0)\nabb_pick_pose = (484.1, 151.4, 446.6, 0.019, 0.006, 1.335)\nabb_drop_pose = (484.3, -388.3, 303, 0.017, 0.004, 1.335)\n\ndef wait_for(key, value):\n  while (read(controller, key) != value):\n    pass\n\ndef wait_for_left_sensor_touched():\n  wait_for(LEFT_SENSOR_IO, True)\n\ndef wait_for_right_sensor_touched():\n  wait_for(RIGHT_SENSOR_IO, True)\n\ndef move_conveyor_belt_to_the_left():\n  already_left = read(controller, LEFT_SENSOR_IO)\n  if (already_left == False):\n    wait_for(RIGHT_SENSOR_IO, True)\n    write(controller, \"digital_out[4]\", True)\n    write(controller, \"digital_out[5]\", True)\n    write(controller, \"digital_out[6]\", False)\n    sync\n\ndef move_conveyor_belt_to_the_right():\n  already_right = read(controller, RIGHT_SENSOR_IO)\n  if (already_right == False):\n    wait_for(LEFT_SENSOR_IO, True)\n    write(controller, \"digital_out[4]\", True)\n    write(controller, \"digital_out[5]\", False)\n    write(controller,  \"digital_out[6]\", True)\n    sync\n\ndef abb_gripper(open):\n  if open:\n    write(controller, \"digital_out[0]\", True)\n    write(controller, \"digital_out[1]\", False)\n    write(controller, \"digital_out[2]\", True)\n  else:\n    write(controller, \"digital_out[0]\", True)\n    write(controller, \"digital_out[1]\", True)\n    write(controller, \"digital_out[2]\", False)\n\ndef ur_gripper(on):\n  if on:\n    write(controller, \"tool_out[1]\", True)\n  else:\n    write(controller, \"tool_out[1]\", False)\n\ndef is_red_button_pressed():\n  return read(controller, \"digital_in[2]\") == False\n\ndef is_green_button_pressed():\n  return read(controller, \"digital_in[3]\") == False\n\ndef is_any_sensor_touched():\n  return (is_left_sensor_touched() + is_right_sensor_touched()) == 1\n\n# def is_object_in_drop_position():\n#   return read(controller, \"digital_in[4]\") == 1\n\ndef get_grid_pose(corner_pose, idx):\n  grid_step = 63\n  grid_n = 3\n  dir_1 = (grid_step * modulo(idx, grid_n), 0, 0, 0, 0, 0)\n  dir_2 = (0, grid_step * intdiv(idx, grid_n), 0, 0, 0, 0)\n  pose_for_idx = corner_pose :: dir_1 :: dir_2\n  return pose_for_idx\n\ndef move_ur_to_suck_object(idx):\n  pick_pose = get_grid_pose(ur_pick_pose, idx)\n  move TCP_Sucker via p2p() to pick_pose :: (0, 0, -100)\n  ur_gripper(True)\n  move TCP_Sucker via p2p() to pick_pose\n  move TCP_Sucker via p2p() to pick_pose :: (0, 0, -100)\n\ndef move_ur_to_unsuck_object():\n  move TCP_Sucker via p2p() to ur_drop_pose :: (0, 0, -150)\n  ur_gripper(False)\n  move TCP_Sucker via p2p() to ur_drop_pose\n  wait(2000)\n  move TCP_Sucker via p2p() to ur_drop_pose :: (0, 0, -150)\n  move TCP_Sucker via p2p() to ur_home\n\ndef move_ur_to_hook_object():\n  pick_pose = [211.3, -1036.5, 211.0, 0, pi, 0] # TODO: find pick position\n  move TCP_HookedHook via p2p() to pick_pose :: (0, 0, -100)\n  move TCP_HookedHook via p2p() to pick_pose\n  move TCP_HookedHook via p2p() to pick_pose :: (0, 0, -100)\n\ndef move_ur_to_unhook_object():\n  pick_pose = (0, 0, 100, 0, pi, 0) # TODO: find pick position\n  move TCP_HookedHook via p2p() to pick_pose :: (0, 0, -100)\n  move TCP_HookedHook via p2p() to pick_pose\n  move TCP_HookedHook via p2p() to pick_pose :: (0, 0, -100)\n\ndef move_ur_to_suck_hook():\n  hook_pick_pose = (451, -543.7, 107.6, 0, pi, 0)\n  move TCP_Sucker via p2p() to hook_pick_pose :: (0, 0, -100)\n  move TCP_Sucker via p2p() to hook_pick_pose\n  ur_gripper(True)\n  move TCP_Sucker via p2p() to hook_pick_pose :: (0, 0, -100)\n\ndef move_ur_to_unsuck_hook():\n  hook_drop_pose = [451, -543.7, 107.6, 0, pi, 0]\n  move TCP_Sucker via p2p() to hook_drop_pose :: (0, 0, -100)\n  move TCP_Sucker via p2p() to hook_drop_pose\n  ur_gripper(False)\n  move TCP_Sucker via p2p() to hook_drop_pose :: (0, 0, -100)\n\ndef move_abb_to_pick_object():\n  with velocity(300):\n    do with robot_abb1200:\n        move TCP_ABB via p2p() to abb_pick_pose :: (0, 0, 100, 0, 0, 0)\n        move TCP_ABB via p2p() to abb_pick_pose\n    abb_gripper(False)\n    wait(1000)\n    do with robot_abb1200:\n        move TCP_ABB via p2p() to abb_pick_pose :: (0, 0, 100)\n\ndef move_abb_to_drop_object():\n  with velocity(300):\n    do with robot_abb1200:\n        move TCP_ABB via p2p() to abb_drop_pose :: (0, 0, 100)\n        move TCP_ABB via p2p() to abb_drop_pose :: (0, 0, 0, 0, 0, 0)\n        move TCP_ABB via p2p() to abb_drop_pose :: (-200, 200, 0, 0, 0, 0)\n    abb_gripper(True)\n    wait(500)\n    do with robot_abb1200:\n        move TCP_ABB via p2p() to abb_drop_pose :: (-200, 200, 100)\n\ndef reset_cell():\n  ur_gripper(False)\n  abb_gripper(False)\n  do with robot_ur10e:\n    move TCP_Sucker via p2p() to ur_home\n  #and do with robot_abb1200:\n  #  move via p2p() to abb_home\n  # move_conveyor_belt_to_the_right()\n\ndef skill_suck(idx):\n  # skill_a picks the object with a vacuum gripper\n  move_ur_to_suck_object(idx)\n  move_conveyor_belt_to_the_right()\n  move_ur_to_unsuck_object()\n  move_conveyor_belt_to_the_left()\n  # ABB movement\n  wait_for_left_sensor_touched()\n  move_abb_to_pick_object()\n  sync\n  #abb_gripper(False)\n  move_abb_to_drop_object()\n  sync\n  #abb_gripper(True)\n\ndef skill_hook():\n  # skill_b picks the object with the hook\n  #move_ur_to_suck_hook()\n  #move_ur_to_hook_object()\n  #wait_for_io(controller, RIGHT_SENSOR_IO)\n  #move_ur_to_unhook_object()\n  #move_conveyor_belt_to_the_left()\n  #move_ur_to_unsuck_hook()\n  #wait_for_io(controller, LEFT_SENSOR_IO)\n  #move_abb_to_pick_object()\n  #move_abb_to_drop_object()\n  print(\"hook\")\n\n# -----------------------------------------\n# TESTING\n# -----------------------------------------\n\nvelocity(300)\n# move to home\ndo with robot:\n  move TCP_Sucker via p2p() to ur_home\n  move TCP_Sucker via p2p() to ur_home :: (0, 0, -136)\nand do with robot_abb1200:\n  move TCP_ABB via p2p() to abb_home\n  move TCP_ABB via p2p() to abb_home :: (0, 0, 100)\n\n# abb_pose = read(robot_abb1200, \"pose\")\n# print(abb_pose)\n\n# -----------------------------------------\n# MAIN\n# -----------------------------------------\n\n#abb_pose = read(robot_abb1200, \"BASE/tool0\")\n#print(abb_pose)\n#do with robot_abb1200:\n#  move TCP_ABB via p2p() to abb_home\n#  move TCP_ABB via p2p() to abb_home :: [0, 0, 100]\n#  move TCP_ABB via p2p() to abb_home\n\ni = 0\nwhile True:\n  print(i)\n  button_red_not_pressed = True\n  button_green_not_pressed = True\n\n  while True:\n    button_red_not_pressed = read(controller, RED_BUTTON_IO)\n    button_green_not_pressed = read(controller, GREEN_BUTTON_IO)\n    if button_red_not_pressed == False:\n      break\n    if button_green_not_pressed == False:\n      break\n\n  # reset_cell()\n  if button_red_not_pressed == False:\n    i = 0\n    skill_suck(i)\n  if button_green_not_pressed == False:\n    skill_suck(i)\n\n  i = i + 1\n  if i == 9:\n    i = 0"}
{"task_id": 6, "script_title": "multirobot_3robots_example", "task_description": "Controlling digital outputs and handling I/O signals.", "code": "# ================================================================================\n#  Variables - Kuka Main\n# ================================================================================\nkm_toolrot = (0, 0, 0, pi, 0, 0) ::(0, 0, 0, 0, pi/2, 0)\nkm_pickup_pose_adjust = (0, 0, 0, 0, 0, 0)\n\nkm_home = (-1196.459, 1120.134, 39.639, 0.000, 0.000, -1.571) :: km_toolrot\nkm_home_approach = (-300.631, 1553.848, 713.290, 0.314, 0.149, -2.240) :: km_toolrot\nkm_end = (1124.216, -270.612, 1287.374, 0.000, 0.000, 0.000) :: km_toolrot\n\nkm_pickup = (-1690.493, 595.949, 1402.813, -1.657, 0.000, 2.669) :: km_toolrot :: km_pickup_pose_adjust\nkm_pickup_approach_01 = (-1170, 596.021, 1660.652, -1.618, 0.051, 2.581) :: km_toolrot\nkm_pickup_approach_02 = km_pickup :: (-200, 0, 0, 0, 0, 0)\n\nkm_assembly_01 = (35.734, 1312.842, 1848.345, 0.464, -0.541, 2.484) :: km_toolrot\nkm_assembly_02 = (1467.229, -724.335, 1451.327, 0.098, -0.113, 1.424) :: km_toolrot\nkm_assembly_03 = (1934.054, -255.538, 1220.853, 0.000, 0.000, 1.571) :: km_toolrot\nkm_assembly_04 = (1934.054, 135.126, 1853.223, -0.373, 0.373, 1.538) :: km_toolrot\nkm_assembly_05 = (1934.054, 1264.324, 1228.771, -0.373, 0.373, 1.538) :: km_toolrot\nkm_assembly_06 = (1934.054, 1666.440, 1053.255, -0.128, 0.128, 1.567) :: km_toolrot\n\nkm_assembly_07 = (1934.054, 1648.191, 1074, 0.000, 0.000, 1.571) :: km_toolrot :: (-10, 0, 0, 0, 0, 0)\nkm_assembly_workpiece = km_assembly_07 :: (10, 0, 0, 0, 0, 0)\n\n# ================================================================================\n#  Variables - Kuka Side2\n# ================================================================================\nks1_TCProt = (0, 0, 0, 0, 0, pi)\nks1_modifier_01 = (0, 0, -3, 0, 0, -0.03)\nks1_modifier_02 = (0, 0, -0.5, 0, 0, 0.02)\n\nks1_home = (-162.759, 761.844, 1022.213, -2.221, 0.000, 2.221) :: ks1_TCProt\nks1_wait_pose_01 = (1275.687, -641.851, 1150.906, -2.221, -0.000, -2.221) :: ks1_TCProt\nks1_entry_pose_01 = (2020.808, -663.201, 1248.459, 0.836, 0.000, 3.028) :: ks1_TCProt\nks1_assembly_pose_01 = (2464.615, -743.862, 1300, 0.004, -0.091, 3.137) :: ks1_TCProt :: ks1_modifier_01\n\nks1_wait_pose_02 = (1324.971, 302.697, 1113.379, -2.221, -0.000, -2.221) :: ks1_TCProt\nks1_entry_pose_02 = (1995.329, 213.900, 1224.313, -0.793, 0.264, -2.972) :: ks1_TCProt\nks1_assembly_pose_02 = (2468.995, -21.849, 1295, 0.021, -0.210, -3.128) :: ks1_TCProt :: ks1_modifier_02\n\nks1_approach_assembly_01 = ks1_assembly_pose_01 :: (0, 0, -150, 0, 0, 0)\nks1_approach_assembly_02 = ks1_assembly_pose_02 :: (0, 0, -150, 0, 0, 0)\n\n# ================================================================================\n#  Variables - Kuka Side2\n# ================================================================================\n\nks2_TCProt = (0, 0, 0, 0, 0, pi)\nks2_modifier_01 = (0, 0, -3, 0, 0, 1)\nks2_modifier_02 = (0, 0, -3, 0, 0, -1)\n\nks2_home = (-162.759, 761.844, 1022.213, -2.221, 0.000, 2.221) :: ks2_TCProt\nks2_wait_pose_01 = (1082.062, 641.850, 1150.906, -2.221, -0.000, -2.221) :: ks2_TCProt\nks2_entry_pose_01 = (1827.183, 663.200, 1148.459, -0.836, 0.000, -3.028) :: ks2_TCProt\nks2_assembly_pose_01 = (2257.000, 712, 1301.5, -0.0, -0.085, -3.3) :: ks2_TCProt :: ks2_modifier_01\n\nks2_wait_pose_02 = (1131.346, -302.700, 1113.379, -2.221, -0.000, -2.221) :: ks2_TCProt\nks2_entry_pose_02 = (1801.704, -213.900, 1124.313, 0.800, 0.258, 2.990) :: ks2_TCProt\nks2_assembly_pose_02 = (2240.000, -16.190, 1297, 0.023, -0.168, 3.076) :: ks2_TCProt :: ks2_modifier_02\n\nks2_approach_assembly_01 = ks2_assembly_pose_01 :: (0, 0, -100, 0, 0, 0)\nks2_approach_assembly_02 = ks2_assembly_pose_02 :: (0, 0, -100, 0, 0, 0)\n\n# ================================================================================\n# Functions\n# ================================================================================\ndef wake_up():\n    km_pose = read(kuka_main_0, 'pose')\n    ks1_pose = read(kuka_side1_0, 'pose')\n    ks2_pose = read(kuka_side2_0, 'pose')\n    do with kuka_main_0:\n        move via p2p() to km_pose\n    and do with kuka_side1_0:\n        move via p2p() to ks1_pose\n    and do with kuka_side2_0:\n        move via p2p() to ks2_pose\n    sync\n\n# ================================================================================\n# Main Program\n# ================================================================================\nwake_up()\n\ndo with kuka_main_0:\n    move via p2p() to km_home\n\nwait(100)\n\ndo with kuka_side1_0:\n    move via p2p() to ks1_home\nand do with kuka_side2_0:\n    move via p2p() to ks2_home\n\nwait(1000)\nwrite(kuka_main, \"$OUT[1]\", False) # support leg\nwrite(kuka_main, \"$OUT[6]\", False) # Suction Gripper\nwrite(kuka_main, \"$OUT[8]\", False) # robot trigger\n\n#----------home to pickup-------#\ndo with kuka_main_0:\n    move via p2p() to km_home\n    move via line() to km_home_approach\n    move via p2p() to km_pickup_approach_01\n    move via p2p() to km_pickup_approach_02\n    move via line() to km_pickup with velocity(80)\nwrite(kuka_main, \"$OUT[7]\", False) # Suction Assembly\nwait(500)\nwrite(kuka_main, \"$OUT[6]\", True) # Suction Gripper\nwait(1500)\n\nwrite(kuka_main, \"$OUT[1]\", False) # support leg\nwrite(kuka_main, \"$OUT[6]\", False) # Suction Gripper\nwrite(kuka_main, \"$OUT[8]\", False) # robot trigger\n\n#----------pickup to assembly-------#\ndo with kuka_main_0:\n    move via p2p() to km_pickup\n    move via line() to km_pickup_approach_01\nand do with kuka_side1_0:\n    move via p2p() to ks1_home\n    move via p2p() to ks1_wait_pose_01\nand do with kuka_side2_0:\n    move via p2p() to ks2_home\n    move via p2p() to ks2_wait_pose_01\n\nwait(500)\ndo with kuka_main_0:\n    move via p2p() to km_assembly_01\n    move via p2p() to km_assembly_02\n    move via line() to km_assembly_03\n    move via line() to km_assembly_04 with velocity(300)\n    move via line() to km_assembly_05 with velocity(300)\n    move via line() to km_assembly_06 with velocity(300)\n    move via line() to km_assembly_07 with velocity(300)\nwait(500)\nwrite(kuka_main, \"$OUT[7]\", True) # Essembly\nwrite(kuka_main, \"$OUT[6]\", False) # Suction Gripper\nwrite(kuka_main, \"$OUT[1]\", True) # open leg\n\n\n# ---------- Side Robots ---------- #\ndo with kuka_side1_0:\n    move via p2p() to ks1_entry_pose_01\n    move via line() to ks1_approach_assembly_01\nand do with kuka_side2_0:\n    move via p2p() to ks2_entry_pose_01\n    move via line() to ks2_approach_assembly_01\n\n# ---------- Put Ceiling into Chassis ---------- #\n\nwait(500)\ndo with kuka_main_0:\n    move via p2p() to km_assembly_07\n    move via line() to km_assembly_workpiece with velocity(50)\n\nwait(500)\n\n# ---------- Side Robots ---------- #\n# ---------- Back ---------- #\ndo with kuka_side1_0:\n    move via p2p() to ks1_approach_assembly_01\n    move via line() to ks1_assembly_pose_01 with velocity(50)\nand do with kuka_side2_0:\n    move via p2p() to ks2_approach_assembly_01\n    move via line() to ks2_assembly_pose_01 with velocity(50)\n\nwait(200)\n\ndo with kuka_side1_0:\n    move via p2p() to ks1_approach_assembly_01 with velocity(300)\n    move via line() to ks1_entry_pose_01\n    move via line() to ks1_wait_pose_01 with blending(150)\nand do with kuka_side2_0:\n    move via p2p() to ks2_approach_assembly_01 with velocity(300)\n    move via line() to ks2_entry_pose_01\n    move via line() to ks2_wait_pose_01\n\n# ---------- Front ---------- #\n\ndo with kuka_side1_0:\n    move via p2p() to ks1_approach_assembly_02\n    move via line() to ks1_assembly_pose_02 with velocity(50)\nand do with kuka_side2_0:\n    move via p2p() to ks2_approach_assembly_02\n    move via line() to ks2_assembly_pose_02 with velocity(50)\n\nwait(200)\n\ndo with kuka_side1_0:\n    move via p2p() to ks1_approach_assembly_02 with velocity(300)\n    move via line() to ks1_entry_pose_02\n    move via line() to ks1_wait_pose_02 with blending(150)\nand do with kuka_side2_0:\n    move via p2p() to ks2_approach_assembly_02 with velocity(300)\n    move via line() to ks2_entry_pose_02\n    move via line() to ks2_wait_pose_02\n\n# ---------- Back to Home ---------- #\n\nwait(1000)\nwrite(kuka_main, \"$OUT[1]\", False)\nwait(1000)\n\ndo with kuka_main_0:\n    move via line() to km_assembly_06 with velocity(50)\n    move via line() to km_assembly_05 with velocity(300)\n    move via line() to km_assembly_04 with velocity(300)\n    move via line() to km_assembly_03\n    move via p2p() to km_assembly_02\n    move via p2p() to km_end"}
{"task_id": 7, "script_title": "physical", "task_description": "Adding and manipulating colliders in a collision scene.", "code": "# robot poses\nUR_HOME = (508.1, 140.1, 569.2, pi, 0, 0)\n\nUR_PICK_01 = (-13.8, -374.2, 337.0, pi, 0, 0)\nUR_PICK_APPROACH_OFFSET = -100\n\nUR_PLACE = (404.0, 535.4, 457.5, pi, 0, 0)\nUR_PLACE_APPROACH_OFFSET = -80\n\nABB_HOME = (524.6, -250.3, 578.4, 0, 0, 2.9)\nABB_PICK_APPROACH = (400.9, -397.6, 460, 0, 0, 2.9)\nABB_PICK = (400.9, -397.6, 421.8, 0, 0, 2.9)\nABB_DROP = (25.5, 673.5, 424.8, 0, 0, 2.9)\n\n# Conveyor:\n# Run the conveyor to the right (velocity > 0)\nCONVEYOR_TRIGGER = \"digital_out[4]\"\nCONVEYOR_LEFT = \"digital_out[5]\"\nCONVEYOR_RIGHT = \"digital_out[6]\"\n\nSENSOR_CONVEYOR_RIGHT = \"digital_in[0]\"\nSENSOR_CONVEYOR_LEFT = \"digital_in[1]\"\n\nDI_04_BUTTON_IO = \"digital_in[4]\"\nDI_05_BUTTON_IO = \"digital_in[5]\"\n\nLIGHT_TABLE = \"digital_out[7]\"\n\n\ndef start_conveyor_right():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, False, \"digital_out[5]\")\n    write(ur, True, \"digital_out[6]\")\n\ndef stop_conveyor():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, False, \"digital_out[5]\")\n    write(ur, False, \"digital_out[6]\")\n\ndef start_conveyor_left():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, True, \"digital_out[5]\")\n    write(ur, False, \"digital_out[6]\")\n\n# UR suction gripper\ndef open_ur_gripper():\n    write(ur, True, \"tool_out[0]\")\n    write(ur, False, \"tool_out[1]\")\n    \ndef close_ur_gripper():\n    write(ur, False, \"tool_out[0]\")\n    write(ur, True, \"tool_out[1]\")\n\n# ABB parallel gripper\ndef open_abb_gripper():\n    write(ur, True, \"digital_out[0]\")\n    write(ur, False, \"digital_out[1]\")\n    write(ur, True, \"digital_out[2]\")\n\ndef close_abb_gripper():\n    write(ur, True, \"digital_out[0]\")\n    write(ur, True, \"digital_out[1]\")\n    write(ur, False, \"digital_out[2]\")\n\nSL_RED = 22\nSL_YELLOW = 21\nSL_GREEN = 20\n\ndef stack_light(light, on):    \n    #write(opcua, on, \"4:Numeric:\" + to_string(light))\n    print(\"OPCUA\")\n\ndef light_table(on):\n    write(ur, on, LIGHT_TABLE)\n\ndef startup():\n    open_ur_gripper()\n    open_abb_gripper()\n    stop_conveyor()\n    start_conveyor_left()\n\ndef get_grid_pose(corner_pose, idx):\n    grid_step = 87\n    grid_n = 3\n    dir_1 = (grid_step * modulo(idx, grid_n), 0, 0, 0, 0, 0]\n    dir_2 = (0, grid_step * intdiv(idx, grid_n), 0, 0, 0, 0]\n    pose_for_idx = corner_pose :: dir_1 :: dir_2\n    return pose_for_idx\n\ndef single_box(box_num):\n    velocity(300)\n    acceleration(300)\n    ur_pick = get_grid_pose(UR_PICK_01, box_num)\n    ur_pick_approach = ur_pick :: (0, 0, UR_PICK_APPROACH_OFFSET, 0, 0, 0]\n\n    do with ur_0:\n        move via p2p() to UR_HOME\n        move via p2p() to ur_pick_approach with velocity(800)\n        move via line() to ur_pick with velocity(50)\n        close_ur_gripper()\n    wait(1000)\n\n    ur_place_approach = UR_PLACE :: (0, 0, UR_PLACE_APPROACH_OFFSET, 0, 0, 0]\n    do with ur_0:\n        move via line() to ur_pick_approach\n        start_conveyor_left()\n        with blending(50), velocity(800):\n            move via p2p() to UR_HOME\n            move via line() to ur_place_approach\n        move via line() to UR_PLACE with velocity(100)\n        open_ur_gripper()\n    wait(1000)\n\n    do with ur_0:\n        start_conveyor_right()\n        move via line() to ur_place_approach\n        move via p2p() to UR_HOME\n    and do with abb_0:\n        move via p2p() to ABB_HOME\n        move via line() to ABB_PICK_APPROACH\n    wait(1000)\n    \n    #wait_for_bool_io(ur, SENSOR_CONVEYOR_RIGHT, True)\n\n    do with abb_0:\n        move via line() to ABB_PICK with velocity(50)\n        stop_conveyor()\n\n        close_abb_gripper()\n    wait(500)\n\n    do with abb_0:\n        move via line() to ABB_PICK_APPROACH with velocity(50)\n        with blending(50), velocity(350):\n            move via p2p() to ABB_HOME \n            move via p2p() to ABB_DROP\n\n        open_abb_gripper()\n\n    wait(1000)\n\n    do with abb_0:\n        move via line() to ABB_HOME with velocity(350)\n\n    stop_conveyor()\n\ndef main(start_box, end_box):\n    stack_light(SL_RED, True)\n    for box_num = (start_box-1)..(end_box-1):\n        print(box_num)\n        button_di_04_pressed = False\n        button_di_05_pressed = False\n\n        while True:\n            button_di_05_not_pressed = read(ur, DI_05_BUTTON_IO)\n            #if read(ur, DI_04_BUTTON_IO) == True:\n            button_di_04_pressed = True\n            break\n            if read(ur, DI_05_BUTTON_IO) == True:\n                button_di_05_pressed = True\n                break\n\n        # reset_cell()\n        if button_di_04_pressed:\n            print(\"NEXT\")\n            light_table(True)\n            single_box(box_num)\n            button_di_04_pressed = False\n            light_table(False)\n        if button_di_05_pressed:\n            print(\"RESET\")\n            box_num = 0\n            light_table(True)\n            single_box(box_num)\n            button_di_05_pressed = False\n            light_table(False)\n\n    stack_light(SL_RED, False)\n\n\nstartup()\nmain(1, 9)"}
{"task_id": 8, "script_title": "sanding_skill_example", "task_description": "Utilizing comments to explain and annotate code.", "code": "# ### -----------------------------------------------------------\n# ### Includes                          -------------------------\n\ndef set_motor(state, is_active):\n    if is_active:\n        set_io_map(get_aov_motor_ios(state, aov))\n\ndef set_compliance(state, is_active):\n    if is_active:\n        set_io_map(get_aov_compliance_ios(state, aov))\n\ndef align_approach(pose, align_to_origin, flip_axis, use_x_axis):\n    if align_to_origin:\n        return rotate_z_origin_direction(pose, flip_axis, use_x_axis)\n    return rotate_z(pose, flip_axis, use_x_axis)\n\ndef move_via_collision_free_p2p(tool, joints):\n    convex_hulls = [  ]\n    move tool via collision_free_p2p(convex_hulls) to joints\n\ndef move_to_home_safely(flange_tcp_name, workspace_tcp_name, home, workspace_robot_mounting):\n    # ### -----------------------------------------------------------\n    # ### Definitions                       -------------------------\n    pullout_mm = 100\n    lift_mm = 100\n    moving_velocity_slow = 20\n    moving_velocity = 50\n\n\n    # ### -----------------------------------------------------------\n    # ### Path                              -------------------------\n    flange = frame(check_tcp_name(flange_tcp_name))\n    workspace_tcp = frame(check_tcp_name(workspace_tcp_name))\n    workspace_tcp_pose = get_tcp_pose(robot, check_tcp_name(workspace_tcp_name))\n\n    velocity(moving_velocity)\n    current = solve_point_forward(robot, read(robot, \"joints\"), check_tcp_name(workspace_tcp_name))\n\n    up_direction_pose = ~workspace_robot_mounting\n    home_global = workspace_robot_mounting :: solve_point_forward(robot, home, check_tcp_name(flange_tcp_name))\n    current_global = workspace_robot_mounting :: current\n    if home_global[2] - current_global[2] >= lift_mm:\n        pullout = current :: (0, 0, -pullout_mm, 0, 0, 0)\n        lift = up_direction_pose :: (0, 0, lift_mm, 0, 0, 0) :: ~up_direction_pose :: pullout\n\n        velocity(moving_velocity_slow)\n        move workspace_tcp via p2p() to current\n        move workspace_tcp via line() to pullout\n\n        velocity(moving_velocity)\n        move workspace_tcp via line() to lift\n    move_via_collision_free_p2p(workspace_tcp, home)\n\ndef sand_surface(path, pressure, moving_velocity, sanding_velocity, is_hot_sanding, up_direction_pose, start_joints, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_surface):\n    # ### -----------------------------------------------------------\n    # ### Definitions                       -------------------------\n    def align_pose(pose):\n        return align_approach(pose, approach_align_to_origin, approach_flip_axis, approach_use_x_axis)\n\n    ABOVE_HIGH = lift_above_surface\n    ABOVE_CLOSE = 10\n\n\n    # ### -----------------------------------------------------------\n    # ### Path                              -------------------------\n    set_compliance(pressure, is_hot_sanding)\n    velocity(moving_velocity)\n    highest_polygon_pose = get_highest_point(path, up_direction_pose)\n    move_via_collision_free_p2p(sanding_tool, start_joints)\n    move sanding_tool via p2p() to align_pose(highest_polygon_pose :: (0, 0, -ABOVE_HIGH, 0, 0, 0) :: ~tcp_offset)\n    move sanding_tool via line() to align_pose(highest_polygon_pose :: (0, 0, -ABOVE_CLOSE, 0, 0, 0) :: ~tcp_offset)\n    move sanding_tool via line() to align_pose(path[0] :: (0, 0, -ABOVE_CLOSE, 0, 0, 0) :: ~tcp_offset)\n\n    velocity(sanding_velocity)\n    for i = 0..<len(path):\n        if i == 1:\n            set_motor(True, is_hot_sanding)\n        move sanding_tool via line() to align_pose(path(i) :: ~tcp_offset)\n\n\n    velocity(moving_velocity)\n    move sanding_tool via line() to align_pose(path[-1] :: (0, 0, -ABOVE_CLOSE, 0, 0, 0) :: ~tcp_offset)\n    set_motor(False, is_hot_sanding)\n    move sanding_tool via line() to align_pose(highest_polygon_pose :: (0, 0, -ABOVE_CLOSE, 0, 0, 0) :: ~tcp_offset)\n    move sanding_tool via line() to align_pose(highest_polygon_pose :: (0, 0, -ABOVE_HIGH, 0, 0, 0) :: ~tcp_offset)\n    move_via_collision_free_p2p(sanding_tool, start_joints)\n\ndef sand_edge(path, pressure, moving_velocity, sanding_velocity, is_hot_sanding, sanding_tool, start_joints, up_direction_pose, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_edge):\n    # ### -----------------------------------------------------------\n    # ### Definitions                       -------------------------\n    def align_pose(pose):\n        return align_approach(pose, approach_align_to_origin, approach_flip_axis, approach_use_x_axis)\n\n    ABOVE_HIGH = lift_above_edge\n    ABOVE_CLOSE = 10\n\n\n    # ### -----------------------------------------------------------\n    # ### Path                              -------------------------\n    edge_no_approach = slice_array(path, 2, -2)\n    highest_pose = get_highest_point(edge_no_approach, up_direction_pose)\n\n    set_compliance(pressure, is_hot_sanding)\n    velocity(moving_velocity)\n\n    move_via_collision_free_p2p(sanding_tool, start_joints)\n    move sanding_tool via p2p() to align_pose(highest_pose :: (0, 0, -ABOVE_HIGH, 0, 0, 0))\n    move sanding_tool via line() to align_pose(highest_pose :: (0, 0, -ABOVE_CLOSE+1, 0, 0, 0))\n    move sanding_tool via line() to align_pose(edge_no_approach[0] :: (0, 0, -ABOVE_CLOSE, 0, 0, 0) :: ~tcp_offset)\n\n    set_motor(True, is_hot_sanding)\n    velocity(sanding_velocity)\n\n    for i = 0..<len(edge_no_approach):\n        move sanding_tool via line() to align_pose(edge_no_approach[i] :: ~tcp_offset)\n\n    set_motor(False, is_hot_sanding)\n    velocity(moving_velocity)\n\n    move sanding_tool via line() to align_pose(edge_no_approach[-1] :: (0, 0, -ABOVE_CLOSE, 0, 0, 0) :: ~tcp_offset)\n    move sanding_tool via line() to align_pose(highest_pose :: (0, 0, -ABOVE_CLOSE-1, 0, 0, 0)) # The -1 here is to prevent a wbr bug https://wandelbots.atlassian.net/browse/AA-1405\n    move sanding_tool via line() to align_pose(highest_pose :: (0, 0, -ABOVE_HIGH, 0, 0, 0))\n    move_via_collision_free_p2p(sanding_tool, start_joints)\n\ndef sand_straight_edge(edge, target_radius, lane_number_range, lane_density_weight, level_distance, pressure, moving_velocity, sanding_velocity, is_hot_sanding, sanding_tool, start_joints, up_direction_pose, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_edge):\n    # ### -----------------------------------------------------------\n    # ### Path                              -------------------------\n    meander = generate_edge_meander(edge[0], edge[1], target_radius, lane_number_range, lane_density_weight, level_distance)\n    sand_edge(meander, pressure, moving_velocity, sanding_velocity, is_hot_sanding, sanding_tool, start_joints, up_direction_pose, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_edge)\n\ndef sand_curved_edge(edge, target_radius, lane_number_range, lane_density_weight, level_distance, pressure, moving_velocity, sanding_velocity, is_hot_sanding, sanding_tool, start_joints, up_direction_pose, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_edge):\n    # ### -----------------------------------------------------------\n    # ### Path                              -------------------------\n    meander = generate_curved_edge_meander(edge[0], edge[1], target_radius, lane_number_range, lane_density_weight, level_distance)\n    sand_edge(meander, pressure, moving_velocity, sanding_velocity, is_hot_sanding, sanding_tool, start_joints, up_direction_pose, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_edge)\n\ndef sand_planar_surface(poly, distance, margin, pressure, moving_velocity, sanding_velocity, is_hot_sanding, up_direction_pose, start_joints, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_surface):\n    # ### -----------------------------------------------------------\n    # ### Path                              -------------------------\n    meander = generate_plane_meander(poly, distance, margin)\n    sand_surface(meander, pressure, moving_velocity, sanding_velocity, is_hot_sanding, up_direction_pose, start_joints, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_surface)\n\ndef sand_curved_surface(pcd, distance, margin, pressure, moving_velocity, sanding_velocity, is_hot_sanding, up_direction_pose, start_joints, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_surface):\n    # ### -----------------------------------------------------------\n    # ### Path                              -------------------------\n    meander = generate_curved_surface_meander(pcd, distance, margin)\n    sand_surface(meander, pressure, moving_velocity, sanding_velocity, is_hot_sanding, up_direction_pose, start_joints, tcp_offset, approach_align_to_origin, approach_flip_axis, approach_use_x_axis, lift_above_surface)\n\n# ### -----------------------------------------------------------\n# ### Input parameters                  -------------------------\n\n# General\npolygons = read(arguments, \"polygons\")\nedges = read(arguments, \"edges\")\ncurved_edges = read(arguments, \"curved_edges\")\ncurved_surfaces = read(arguments, \"curved_surfaces\")\nhot_sanding_on = True\nsafety_offset_z = 0 # (mm) positive value goes away from the workpiece\nmoving_velocity = 1000\nworkspace_robot_mounting = (0,0,0,0,0,0)\nworkspace_tcp = \"TOOL 5\"\nhome = [-0.08263993263244629,0.17805440723896027,0.4916095733642578,0.014160103164613247,-2.345040798187256,1.635414719581604]\nuse_approach_optimization = False\napproach_align_to_origin = False\napproach_flip_axis = False\napproach_use_x_axis = False\n\n# ### -----------------------------------------------------------\n# ### Definitions                       -------------------------\ndef align_pose(pose):\n    return align_approach(pose, approach_align_to_origin, approach_flip_axis, approach_use_x_axis)\n\n# Safety features\nMOVING_OFFSET_HIGHEST = 150\n\n# Path optimization features\nuse_start_joint_search = False\n\nmax_allowed_joint_deviations = [1, 1, 3, 3, 6, 6]\napply_operation_sync = use_start_joint_search\n\n# ### -----------------------------------------------------------\n# ### Configuration settings (developer can change) -------------\nsanding_tool = frame(check_tcp_name(workspace_tcp))\ntcp_pose = get_tcp_pose(robot, check_tcp_name(workspace_tcp))\ntcp_correction_offset = (0, 0, 0, 0, 0, 0)  # Normally set to zero (This gets applied to the points before the actual robot TCP is used)\n\n# Construct the via pose:\nup_direction_pose = ~workspace_robot_mounting\nhighest_pose = get_highest_point(polygons + edges + curved_surfaces + curved_edges, up_direction_pose)\nabove_workpiece = (highest_pose[0], highest_pose[1], highest_pose[2], 0, 0, 0) :: up_direction_pose :: (0, 0, MOVING_OFFSET_HIGHEST, 0, 0, 0) :: (0, 0, 0, pi, 0, 0)\nabove_workpiece = align_pose(above_workpiece)\n\n# ### -----------------------------------------------------------\n# ### Preparation (don't change) --------------------------------\nsafety_offset = (0, 0, safety_offset_z, 0, 0, 0)\n\nif hot_sanding_on:\n    tcp_offset = tcp_correction_offset\nelse:\n    # This variable is kind of a 'local/relative' tcp, in relation to the actual used TCP of the robot\n    tcp_offset = tcp_correction_offset :: safety_offset\n\n# ### -----------------------------------------------------------\n# ### Skill starts              ---------------------------------\nabove_workpiece_joints = solve_point_inverse(robot, above_workpiece :: ~tcp_offset, check_tcp_name(workspace_tcp), home)\n\nblending(10)\nvelocity(moving_velocity)\nmove_via_collision_free_p2p(sanding_tool, home)\nmove_via_collision_free_p2p(sanding_tool, above_workpiece_joints)\n\n\nsand_straight_edge(edges[0], 4, [5,17], 0.2, 100, 0.5, moving_velocity, 100, hot_sanding_on, sanding_tool, above_workpiece_joints, up_direction_pose, tcp_offset, False, False, False, 100)\nif apply_operation_sync:\n    sync\nsand_straight_edge(edges[1], 4, [5,17], 0.2, 100, 0.5, moving_velocity, 100, hot_sanding_on, sanding_tool, above_workpiece_joints, up_direction_pose, tcp_offset, False, False, False, 100)\nif apply_operation_sync:\n    sync\n\n\nsand_planar_surface(polygons[0], 80, 0, 2, moving_velocity, 100, hot_sanding_on, up_direction_pose, above_workpiece_joints, tcp_offset, False, False, False, 100)\nif apply_operation_sync:\n    sync\nsand_planar_surface(polygons[1], 80, 0, 2, moving_velocity, 100, hot_sanding_on, up_direction_pose, above_workpiece_joints, tcp_offset, False, False, False, 100)\nif apply_operation_sync:\n    sync\n\n# ### -----------------------------------------------------------\nmove_via_collision_free_p2p(sanding_tool, home)\n\n# Motions are not resolved at this point\nmotion = motion_trajectory_to_json_string(robot)"}
{"task_id": 9, "script_title": "twin", "task_description": "Managing robot poses using context managers.", "code": "# robot poses\nUR_HOME = (508.1, 140.1, 569.2, pi, 0, 0)\n\nUR_PICK_01 = (-13.8, -374.2, 337.0, pi, 0, 0)\nUR_PICK_APPROACH_OFFSET = -100\n\nUR_PLACE = (404.0, 535.4, 448.5, pi, 0, 0)\nUR_PLACE_APPROACH_OFFSET = -80\n\nABB_HOME = (524.6, -250.3, 578.4, 0, 0, 2.9)\nABB_PICK_APPROACH = (398, -450.6, 460, 0, -0.3, 2.9)\nABB_PICK = (398, -450.6, 420, 0, -0.3, 2.9)\nABB_DROP = (25.5, 673.5, 424.8, 0, 0, 2.9)\n\n# Conveyor:\n# Run the conveyor to the right (velocity > 0)\nCONVEYOR_TRIGGER = \"digital_out[4]\"\nCONVEYOR_LEFT = \"digital_out[5]\"\nCONVEYOR_RIGHT = \"digital_out[6]\"\n\nSENSOR_CONVEYOR_RIGHT = \"digital_in[0]\"\nSENSOR_CONVEYOR_LEFT = \"digital_in[1]\"\n\nDI_04_BUTTON_IO = \"digital_in[4]\"\nDI_05_BUTTON_IO = \"digital_in[5]\"\n\nLIGHT_TABLE = \"digital_out[7]\"\n\nUR_TCP = frame(\"TCP\")\n\n# Set this to true when you run the skill only on virtual robot\nIS_ONLY_VIRTUAL = False \n\ndef start_conveyor_right():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, False, \"digital_out[5]\")\n    write(ur, True, \"digital_out[6]\")\n\ndef stop_conveyor():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, False, \"digital_out[5]\")\n    write(ur, False, \"digital_out[6]\")\n\ndef start_conveyor_left():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, True, \"digital_out[5]\")\n    write(ur, False, \"digital_out[6]\")\n\n# UR suction gripper\ndef open_ur_gripper():\n    write(ur, True, \"tool_out[0]\")\n    write(ur, False, \"tool_out[1]\")\n    \ndef close_ur_gripper():\n    write(ur, False, \"tool_out[0]\")\n    write(ur, True, \"tool_out[1]\")\n\n# ABB parallel gripper\ndef open_abb_gripper():\n    write(ur, True, \"digital_out[0]\")\n    write(ur, False, \"digital_out[1]\")\n    write(ur, True, \"digital_out[2]\")\n\ndef close_abb_gripper():\n    write(ur, True, \"digital_out[0]\")\n    write(ur, True, \"digital_out[1]\")\n    write(ur, False, \"digital_out[2]\")\n\nSL_RED = 22\nSL_YELLOW = 21\nSL_GREEN = 20\n\ndef stack_light(light, on):    \n    if IS_ONLY_VIRTUAL == True:\n        print(\"OPCUA is not yet supported.\")\n    #else:\n    #    write(opcua, on, \"4:Numeric:\" + to_string(light))\n\ndef light_table(on):\n    write(ur, on, LIGHT_TABLE)\n\ndef startup():\n    open_ur_gripper()\n    open_abb_gripper()\n    stop_conveyor()\n    start_conveyor_left()\n\ndef get_grid_pose(corner_pose, idx):\n    grid_step = 87\n    grid_n = 3\n    dir_1 = (grid_step * modulo(idx, grid_n), 0, 0, 0, 0, 0]\n    dir_2 = (0, grid_step * intdiv(idx, grid_n), 0, 0, 0, 0]\n    pose_for_idx = corner_pose :: dir_1 :: dir_2\n    return pose_for_idx\n\ndef single_box(box_num):\n    velocity(200)\n    acceleration(200)\n    ur_pick = get_grid_pose(UR_PICK_01, box_num)\n    ur_pick_approach = ur_pick :: (0, 0, UR_PICK_APPROACH_OFFSET, 0, 0, 0]\n\n    do with ur_0:\n        move UR_TCP via p2p() to UR_HOME\n        move UR_TCP via p2p() to ur_pick_approach with velocity(800)\n        move UR_TCP via line() to ur_pick with velocity(50)\n        close_ur_gripper()\n    wait(1000)\n\n    ur_place_approach = UR_PLACE :: (0, 0, UR_PLACE_APPROACH_OFFSET, 0, 0, 0]\n    do with ur_0:\n        move UR_TCP via line() to ur_pick_approach\n        start_conveyor_left()\n        with blending(50), velocity(800):\n            move UR_TCP via p2p() to UR_HOME\n            move UR_TCP via line() to ur_place_approach\n        move UR_TCP via line() to UR_PLACE with velocity(100)\n        open_ur_gripper()\n    wait(1000)\n\n    do with ur_0:\n        start_conveyor_right()\n        move UR_TCP via line() to ur_place_approach\n        move UR_TCP via p2p() to UR_HOME\n    and do with abb_0:\n        move via p2p() to ABB_HOME\n        move via line() to ABB_PICK_APPROACH\n    \n    if IS_ONLY_VIRTUAL == False:\n        wait_for_bool_io(ur, SENSOR_CONVEYOR_RIGHT, True)\n    else:\n        wait(1000)\n\n    do with abb_0:\n        move via line() to ABB_PICK with velocity(50)\n        stop_conveyor()\n\n        close_abb_gripper()\n    wait(500)\n\n    do with abb_0:\n        move via line() to ABB_PICK_APPROACH with velocity(50)\n        with blending(50), velocity(200):\n            move via p2p() to ABB_HOME \n            move via p2p() to ABB_DROP\n\n        open_abb_gripper()\n        move via line() to ABB_DROP :: (0, 0, 10] with velocity(200)\n\n    wait(1000)\n\n    do with abb_0:\n        move via line() to ABB_HOME with velocity(200)\n\n    stop_conveyor()\n\ndef main(start_box, end_box):\n    stack_light(SL_RED, True)\n    for box_num = (start_box-1)..(end_box-1):\n        print(box_num)\n        button_di_04_pressed = False\n        button_di_05_pressed = False\n\n        while True:\n            button_di_05_not_pressed = read(ur, DI_05_BUTTON_IO)\n            if read(ur, DI_04_BUTTON_IO) == True:\n                button_di_04_pressed = True\n                break\n            if read(ur, DI_05_BUTTON_IO) == True:\n                button_di_05_pressed = True\n                break\n\n        # reset_cell()\n        if button_di_04_pressed:\n            print(\"NEXT\")\n            light_table(True)\n            single_box(box_num)\n            button_di_04_pressed = False\n            light_table(False)\n        if button_di_05_pressed:\n            print(\"RESET\")\n            box_num = 0\n            light_table(True)\n            single_box(box_num)\n            button_di_05_pressed = False\n            light_table(False)\n\n    stack_light(SL_RED, False)\n\n\nstartup()\nmain(1, 9)"}
{"task_id": 10, "script_title": "virtual", "task_description": "Reading from and writing to a controller\u2019s digital outputs.", "code": "# robot poses\nUR_HOME = (508.1, 140.1, 569.2, pi, 0, 0)\n\nUR_PICK_01 = (-13.8, -374.2, 337.0, pi, 0, 0)\nUR_PICK_APPROACH_OFFSET = -100\n\nUR_PLACE = (404.0, 535.4, 448.5, pi, 0, 0)\nUR_PLACE_APPROACH_OFFSET = -80\n\nABB_HOME = (524.6, -250.3, 578.4, 0, 0, 2.9)\nABB_PICK_APPROACH = (400.9, -397.6, 460, 0, 0, 2.9)\nABB_PICK = (400.9, -397.6, 421.8, 0, 0, 2.9)\nABB_DROP = (25.5, 673.5, 424.8, 0, 0, 2.9)\n\n# Conveyor:\n# Run the conveyor to the right (velocity > 0)\nCONVEYOR_TRIGGER = \"digital_out[4]\"\nCONVEYOR_LEFT = \"digital_out[5]\"\nCONVEYOR_RIGHT = \"digital_out[6]\"\n\nSENSOR_CONVEYOR_RIGHT = \"digital_in[0]\"\nSENSOR_CONVEYOR_LEFT = \"digital_in[1]\"\n\nDI_04_BUTTON_IO = \"digital_in[4]\"\nDI_05_BUTTON_IO = \"digital_in[5]\"\n\nLIGHT_TABLE = \"digital_out[7]\"\n\nUR_TCP = frame(\"TCP\")\n\n# Set this to true when you run the skill only on virtual robot\nIS_ONLY_VIRTUAL = True \n\ndef start_conveyor_right():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, False, \"digital_out[5]\")\n    write(ur, True, \"digital_out[6]\")\n\ndef stop_conveyor():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, False, \"digital_out[5]\")\n    write(ur, False, \"digital_out[6]\")\n\ndef start_conveyor_left():\n    write(ur, True, \"digital_out[4]\")\n    write(ur, True, \"digital_out[5]\")\n    write(ur, False, \"digital_out[6]\")\n\n# UR suction gripper\ndef open_ur_gripper():\n    write(ur, True, \"tool_out[0]\")\n    write(ur, False, \"tool_out[1]\")\n    \ndef close_ur_gripper():\n    write(ur, False, \"tool_out[0]\")\n    write(ur, True, \"tool_out[1]\")\n\n# ABB parallel gripper\ndef open_abb_gripper():\n    write(ur, True, \"digital_out[0]\")\n    write(ur, False, \"digital_out[1]\")\n    write(ur, True, \"digital_out[2]\")\n\ndef close_abb_gripper():\n    write(ur, True, \"digital_out[0]\")\n    write(ur, True, \"digital_out[1]\")\n    write(ur, False, \"digital_out[2]\")\n\nSL_RED = 22\nSL_YELLOW = 21\nSL_GREEN = 20\n\ndef stack_light(light, on):    \n    if IS_ONLY_VIRTUAL == True:\n        print(\"OPCUA is not yet supported.\")\n    else:\n        write(opcua, on, \"4:Numeric:\" + to_string(light))\n\ndef light_table(on):\n    write(ur, on, LIGHT_TABLE)\n\ndef startup():\n    open_ur_gripper()\n    open_abb_gripper()\n    stop_conveyor()\n    start_conveyor_left()\n\ndef get_grid_pose(corner_pose, idx):\n    grid_step = 87\n    grid_n = 3\n    dir_1 = (grid_step * modulo(idx, grid_n), 0, 0, 0, 0, 0]\n    dir_2 = (0, grid_step * intdiv(idx, grid_n), 0, 0, 0, 0]\n    pose_for_idx = corner_pose :: dir_1 :: dir_2\n    return pose_for_idx\n\ndef single_box(box_num):\n    velocity(400)\n    acceleration(300)\n    ur_pick = get_grid_pose(UR_PICK_01, box_num)\n    ur_pick_approach = ur_pick :: (0, 0, UR_PICK_APPROACH_OFFSET, 0, 0, 0]\n\n    do with ur_0:\n        move UR_TCP via p2p() to UR_HOME\n        move UR_TCP via p2p() to ur_pick_approach with velocity(800)\n        move UR_TCP via line() to ur_pick with velocity(50)\n        close_ur_gripper()\n    wait(1000)\n\n    ur_place_approach = UR_PLACE :: (0, 0, UR_PLACE_APPROACH_OFFSET, 0, 0, 0]\n    do with ur_0:\n        move UR_TCP via line() to ur_pick_approach\n        start_conveyor_left()\n        with blending(50), velocity(800):\n            move UR_TCP via p2p() to UR_HOME\n            move UR_TCP via line() to ur_place_approach\n        move UR_TCP via line() to UR_PLACE with velocity(100)\n        open_ur_gripper()\n    wait(1000)\n\n    do with ur_0:\n        start_conveyor_right()\n        move UR_TCP via line() to ur_place_approach\n        move UR_TCP via p2p() to UR_HOME\n    and do with abb_0:\n        move via p2p() to ABB_HOME\n        move via line() to ABB_PICK_APPROACH\n    \n    if IS_ONLY_VIRTUAL == False:\n        wait_for_bool_io(ur, SENSOR_CONVEYOR_RIGHT, True)\n    else:\n        wait(1000)\n\n    do with abb_0:\n        move via line() to ABB_PICK with velocity(50)\n        stop_conveyor()\n\n        close_abb_gripper()\n    wait(500)\n\n    do with abb_0:\n        move via line() to ABB_PICK_APPROACH with velocity(50)\n        with blending(50), velocity(350):\n            move via p2p() to ABB_HOME \n            move via p2p() to ABB_DROP\n\n        start_conveyor_left()\n        open_abb_gripper()\n        move via line() to ABB_DROP :: (0, 0, 10] with velocity(200)\n\n    wait(1000)\n\n    do with abb_0:\n        move via line() to ABB_HOME with velocity(500)\n\n    stop_conveyor()\n\ndef main(start_box, end_box):\n    stack_light(SL_RED, True)\n    for box_num = (start_box-1)..(end_box-1):\n        print(box_num)\n        button_di_04_pressed = True\n        button_di_05_pressed = False\n\n        # reset_cell()\n        if button_di_04_pressed:\n            print(\"NEXT\")\n            light_table(True)\n            single_box(box_num)\n            button_di_04_pressed = False\n            light_table(False)\n        if button_di_05_pressed:\n            print(\"RESET\")\n            box_num = 0\n            light_table(True)\n            single_box(box_num)\n            button_di_05_pressed = False\n            light_table(False)\n\n    stack_light(SL_RED, False)\n\n\nstartup()\n#main(1, 9)\nmain(1, 1)\nmain(3, 3)\nmain(5, 5)\nmain(7, 7)\nmain(9, 9)"}
